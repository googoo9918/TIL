## 웹의 구성
- 웹(Web)은 인터넷에서 제공되는 HyperText 시스템이다.

> HyperText : 문서안에 다른 문서의 위치정보 등을 포함, 문서 간의 정보를 서로 연관 지어 참조 할 수 있는 문서.

## 클라이언트 - 서버 아키텍쳐
![image](https://user-images.githubusercontent.com/102513932/193806197-45025091-0fa7-418a-afe5-e0f4ef55925e.png)
- 클라이언트
  - 주로 서비스 이용
  - 사용자가 직접 이용, 편의성이나 휴대성을 고려해 개발 진행
- 서버
  - 유지보수를 제외하고 24시간 작동 요망
  - 사용자와 직접적 접점 X, 편의성보단 기능 중점

- 2티어 아키텍쳐
  - ![image](https://user-images.githubusercontent.com/102513932/193807200-b6ee8384-3726-4366-9a3e-f73d8b9a5516.png)
  - 상품 정보 같은 리소스가 존재하는 곳 / 리소스를 사용하는 앱을 분리 
    - 2티어 아키텍처, 클라이언트-서버 아키텍처라 지칭
  - 리소스를 사용하는 앱 : 클라이언트
  - 리소스를 제공 : 서버
  - 상품 정보는 서버에서 다루고, 클라이언트는 단지 상품 정보를 조회할 뿐

## 웹 애플리케이션 아키텍쳐
![image](https://user-images.githubusercontent.com/102513932/193807845-a16d947a-f163-4984-befb-eaac6bce9dd8.png)

- 웹 애플리케이션
  - 웹 브라우저에서 이용할 수 있는 응용 소프트웨어
    - 막대한 트래픽에 노출될 수 있음
      - 신뢰성, 확장성, 보안성, 견고성 고려 요망
- 웹 애플리케이션 특징
  - 데스크탑 애플리케이션 처럼 상호작용 가능
  - 특정 기능 가짐 (ex 정보검색)
  - 정보나 자료 등의 콘텐츠 관리 시스템과 함께 작동
  - website는 정적 페이지들의 집합체, 웹사이트가 동적 페이지를 포함하게 된다면 web application이 된다.
- 웹 애플리케이션 아키텍쳐
  - 응용 프로그램의 구성 요소 간의 상호 작용을 유지하는 소프트웨어를 구조화 한 것
    - 클라이언트 - 서버 간의 연결에 대한 설명 방법
    - 어떻게 애플리케이션 내부의 요소들이 상호간에 소통하는지 설명
    - 애플리케이션의 다양한 요소
      - 브라우저, 유저 인터페이스, 미들웨어, 서버, 데이터베이스
    - 이러한 요소들이 상호작용 할 수 있도록 결부시키는 뼈대

## 웹 애플리케이션의 요청 흐름

- ```https://urclass.codestates.com```으로 접속 시
  - 1. 브라우저에 ```https://urclass.codestates.com```입력
  - 2. 브라우저는 서버의 주소를 찾기 위해 DNS 서버에 요청을 보냄
  - 3. IP 주소를 찾으면 해당 주소에 HTTPS 요청을 보냄
    - 이미 기록이 캐시 메모리에 있으면 주소를 캐시 메모리에서 가져옴
  - 4. 웹 서버에 요청 도착
  - 5. 웹 서버는 저장소에 요청을 보내 페이지 관련 데이터들을 가져옴
  - 6. 정보들을 가져오는 중에 비지니스 로직이 작용함
  - 7. 비즈니스 로직들은 각 데이터들을 어떻게 다룰지 정해짐
  - 8. 로직들을 통해 요청 받은 데이터들이 처리됨, 브라우저에 응답합
  - 9. 요청들이 브라우저에 응답으로 돌아왔을 때, 웹 페이지 화면에서 출력됨.
  - 모든 애플리케이션은 client-side와 server-side로 동작
    - client-side
      - 유저의 입력에 따라 브라우저에서 작동
      - 주로 HTML, CSS, JavaScript의 언어를 조합해 개발 진행
      - 개발되는 코드는 브라우저에 의해 분석되어 처리
      - 서버와의 소통은 HTTP 요청을 통해 이루어짐
    - server-side
      - HTTP 요청에 따라 서버에서 요청 처리
      - Java, Python, JavaScript, C#, PHP등 서버 사이드에서 실행 가능하고 HTTP 요청에 응답할 수 있는 언어들 사용
- ### 웹 애플리케이션의 요소들
  - 유저 인터페이스 요소
    - 유저 경험과 관련된 요소들
    - 화면 출력, 로그, 알림, 시스템 통계, 환경 설정 등 웹 애플리케이션의 기능적 부분 외적인 요소들
  - 구조 요소
    - 웹 애플리케이션 기능의 기능적 부분 담당
    - 유저와 상호작용, 제어, 데이터베이스 등에 관련된 요소
    - 웹 애플리케이션의 전체적인 구조 담당
    - 웹 브라우저, 클라이언트, 웹 애플리케이션 서버, 데이터베이스로 구성
- ### 웹 애플리케이션의 3단계 계층 구조
  - ![image](https://user-images.githubusercontent.com/102513932/193816771-dbf0e90f-e285-4ec4-8789-c3494a914e85.png)
  - #### Presentation Layer
    - 브라우저등을 이용해 유저와 직접적으로 접촉. 
    - Web Server가 이 영역에 포함, 유저 인터페이스 요소들 포함.
  - #### Application Layer
    - Business Layer, Business Logic 혹은 Domain Logic 이라고 불리기도 함
    - 유저의 요청을 브라우저로부터 받아 처리를 함.
    - Application Server가 이 계층에 포함
    - 데이터 접근을 위한 경로를 규격화 하는 등의 과정이 작성됨
  - #### Data access layer
    - Persistence layer이라고 불리기도 함
    - 애플리케이션의 데이터 저장소에 접근, 데이터를 불러 오거나 저장을 담당
    - Application Layer의 로직들이 데이터베이스에 접근하여 데이터 회수 및 저장하는 구조를 최적화
  - Cross-cutting
    - 보안, 통신, 운영 관리등을 위한 요소
  - Third-party integrations
    -  제 3의 API 서비스를 이용하는 것을 의미
    -  EX) OAuth 2.0을 이용한 소셜 로그인, PG사를 이용한 결재기능 등
  
## 웹 애플리케이션의 구현
### 웹 애플리케이션 구현방식
#### Single Page Application
![2022-10-04 21;36;38](https://user-images.githubusercontent.com/102513932/193821264-dc566f08-134b-4b28-b4e2-89370609ec81.gif)
- 유저의 입력과 요청에 의한 콘텐츠, 정보의 최신화가 페이지를 새로 불러오지 않고 현재 페이지에서 이루어 짐
  - 요청한 응답을 기다리며 페이지와 상호작용 가능
- 필수적 요소만을 요청, 페이지 새로 고침을 방지하여 유저 경험 극대화
- AJAX, Asynchronous JavaScript, XML 주로 사용

#### Microservice architecture
- 작은 서비스 여러개가 모여 하나의 시스템을 제공하는 아키텍쳐
  - 각 애플리케이션의 기능 요소들은 상호간에 의존적으로 설계되지 않음
    - 개발단계에서, 개발 완성 이후로 같은 개발 언어를 사용할 필요가 없음
    - 기능 개발의 유연성, 개발 과정의 전반적인 속도와 생산성 향상
  - 서비스간 통신방법 어려움, 테스트 어려움, 통합적인 유지관리 어려움

#### Serverless Architecture
- 개발자가 웹 애플리케이션의 서버와 기타 기반 기능들에 대해 외부의 제 3자인 클라우드 서비스 제공자에게 의탁하는 방식
  - 개발자가 기본적인 서버나 기반 기능들에 걱정할 필요 없이 특정기능 개발에 집중할 수 있게 함
  - 유지보수 어려움

### 웹 애플리케이션 구현 기술

#### HTTP
![image](https://user-images.githubusercontent.com/102513932/193823223-1aa05664-240a-4c01-b186-eefa8b02d030.png)
- HTTP(HyperText Transfer Protocol)
  - 웹 브라우저상에서 클라이언트와 서버간의 통신을 담당하는 프로토콜
  - 클라이언트의 데이터 요창과 서버에서의 요청에 대한 응답을 반복하며 웹 애플리케이션을 작동시킴
  - 요청에 하고싶은 처리의 종류를 나타내는 메서드의 이름, 처리 대상의 이름 포함
  - 응답에 요청에 대한 처리 결과를 나타내는 상태 코드, 헤더, 실제 처리결과인 메시지 포함
  - 대용량 이미지, 음성, 영상, 파일 데이터 등 거의 모든 방식의 데이터 전송을 HTTP를 이용해 처리
  
#### Cookie 와 Session
- HTTP는 데이터를 요청하고 요청에 대한 응답을 전송하는 무상태성의 프로토콜
  - 무상태성을 지니기 때문에 이를 보완할 수 있는 기능 필요
- 쿠키
  - 유저의 정보를 클라이언트에 보관
  - 다음 접속부터 클라이언트가 유저의 정보를 서버로 보내서 유저를 서버가 식별하게 함.
  - 쿠키에 담긴 내용으로 다음 접속에도 이어서 같은 방식으로 작동하게 도와줌.
- 세션
  - 서버에 Session-ID라는 고유 아이디 할당으로 유저 식별
  - 유출되면 안되는 정보는 서버에서 관리하며 세션 ID와 매칭하여 저장해 관리
  - 세션정보는 주로 쿠키에서 관리, 실제 매칭되는 값들은 서버 측에서 관리하는 것이 일반적

#### 사용자 인증
- 고유 아이디와 암호 뿐 아니라, 개인의 신원또한 파악하는 다요소 인증(MFA)가 보안의 필수 요소가 됨.
  - 은행같이 더 높은 수준의 보안을 요구하는 서비스는 OTP를 사용하기도 함.
  - 혹은 urclass 인증과 같이 OAuth 방식을 이용, 서비스 자격증명 매커니즘을 제 3의 서비스에 위임해 인증.


## SSR과 CSR

### SSR
![image](https://user-images.githubusercontent.com/102513932/193838963-f55db370-bbcf-44a0-9c8f-8a282515ff4e.png)
- SSR(Server Sider Rendering)
  - 서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식
    - 1. 유저가 브라우저를 방문하고 브라우저가 서버에게 컨텐츠를 요청
    - 2. 서버에서는 요청을 받자마자 즉시 필요한 데이터들을 넣어 HTML을 구성, 만들어진 HTML과 JS코드를 브라우저에 넘긴다.
    - 3. 브라우저에서는 전달받은 HTML 띄운 뒤 JS코드를 다운로드, HTML에 JS로직을 연결시켜 구동
      - 렌더링
        - HTML로 입력받아 해석 후 표준 출력 장치(모니터)로 출력 하는 것
  - 웹 페이지의 내용에 데이터베이스의 데이터가 필요한 경우
    - 서버는 데이터베이스의 데이터를 불러온 후 웹 페이지를 완전히 렌더링 된 페이지로 변환, 브라우저에 응답으로 보냄.
  - 사용자가 브라우저의 다른 경로로 이동 시 서버는 이 작업을 다시 수행함.

### CSR
![image](https://user-images.githubusercontent.com/102513932/193839540-30d024da-0b73-4ada-aed9-4d7d9f94eb63.png)
- Client Side Rendering
  - 웹 페이지의 렌더링이 클라이언트 단에서 일어나는 방식
    - 1. 유저가 방문하고 브라우저가 서버에 컨텐츠 요청
    - 2. 서버가 빈 뼈대만 있는 HTML을 응답으로 보내줌
    - 3. 브라우저는 서버와 연결된 JS 링크를 통해 서버로부터 JS 파일을 받아 동적으로 DOM 생성
> DOM(Document Object Model) : XML이나 HTML 문서에 접근하기 위한 인터페이스, 문서 내의 모든 요소를 정의하고 각각의 요소에 접근하는 방법 제공
  - 웹 페이지에 필요한 내용이 데이터베이스에 저장된 데이터인 경우
    - 브라우저는 데이터베이스에 저장된 데이터를 가져와 웹 페이지에 랜더링 해야 함
    - 이를 위해 API 사용
      - 웹 페이지 렌더링 시 필요한 데이터를 API 요청으로 해소
  - 브라우저가 다른 경로로 이동할 시
    - SSR과 다르게, 서버가 웹 페이지를 다시 보내지 않음
    - 브라우저는 브라우저가 요청한 경로에 따라 페이지를 다시 렌더링
      - 웹 페이지의 파일은 맨 처음 서버로부터 전달받은 웹 페이지 파일과 동일한 파일임

### The Differencer
- 주요 차이점
  - 렌더링 되는 위치
    - SSR
      - 서버에서 페이지 렌더링
    - CSR
      - 브라우저에서 페이지 렌더링
      - 브라우저는 사용자가 다른 경로를 요청할 때 페이지를 새로고침 하지 않고, 동적으로 라우팅 관리
> 라우팅 : 네틑워크에서 경로를 선택하는 프로세스

### Characteristic of SSR
- 모든 데이터가 HTML에 담겨진 채로 브라우저에 전송되기 때문에 크롤러 봇이 초기 HTML에서 색인에 필요한 정보 취득 가능
  - 검색 엔진 최적화(SEO)에 유리
- 초기 구동속도가 빠름
  - JS코드가 실행되기 전에도 사용자가 HTML을 통해 화면에서 볼 수 있는 것이 있음
  - 화면은 눈에 보이지만, 버튼 클릭과 같은 인터랙션은 불가능
    - TTV(Time To View)와 TTI(Time To Interact) 사이에 시간 간격 존재
- 자원이용이 서버에 집중, 애플리케이션 유지비용이 높음
- 매번 새로운 HTML을 서버로부터 받아오는 과정에서 전환 시마다 화면 깜빡임 발생
- 일부 서드파티 자바스크립트 라이브러리의 경우, 서버사이드 렌더링 불가능

### Characteristic of CSR
- 브라우저가 JS 파일을 다운받고 DOM을 생성하는 시간을 기다려야 해서 초기 로딩 속도가 느림
- 초기 로딩 이후에는 서버에 필요한 데이터만 요청하여 동적으로 페이지 일부만 리렌더링하기 때문에 이후의 구동 속도는 빠름
- 초기 로딩 이후에는 클라이언트 쪽에서 라우팅이나 연산을 모두 직접 처리
  - 반응속도가 빨라 UX(사용자 경험)이 우수
- 서버는 빈 HTML을 내려주는 역할만 하기 때문에 서버 측의 부하가 적음
- 검색 엔진 최적화(SEO)에는 불리
  - 브라우저의 웹 크롤러는 초기 로딩 시 HTML을 읽어 검색 가능한 색인을 생성
  - CSR 방식에서는 웹 크롤러가 보는 초기 HTML이 비어있어 검색 엔진 색인 어려움
- TTV(Time To View)와 TTI(Time To Interact) 동일
  - HTML은 JS가 모두 연결된 상태에서 렌더링 되기 때문

### Use SSR
> SEO(Search Engine Optimization)(검색 엔진 최적화): 웹사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정

- SEO가 우선순위인 경우, 일반적으로 SSR 사용
- 웹 페이지의 첫 화면 렌더링이 빠르게 필요한 경우, 단일 파일의 용량이 작은 SSR이 적합
- 웹 페이지가 사용자와 상호작용이 적은 경우, SSR 활용 용이

### Use CSR
- SEO가 우선순위가 아닌 경우, CSR 이용
- 사이트에 풍부한 상호 작용이 있는 경우, CSR은 빠른 라우팅으로 강력한 사용자 경험 제공
- 웹 애플리케이션 제작 시, CSR을 이용해 더 나은 사용자 경험(빠른 동적 렌더링) 제공 가능

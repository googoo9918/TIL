# 소프트웨어 분석 및 설계
## Introduction
### 소프트웨어
- 소프트웨어 개발의 어려움
  - 실체를 감지하기 어려움 -> 품질 평가가 어려움
  - 다수 사용자를 대상, 다양한 기능 개발 요구
  - 계속 수정하면 설계 구조가 약화 될 수 있음
- 소프트웨어 위기
  - 하드웨어의 발달로 SW의 수요가 늘고, 규모가 커짐
    - 다만 SW 공급을 높이기 위한 생산성 향상은 더딤
  - 즉, SW 개발 속도가 하드웨어 개발 속도를 따라가지 못해 사용자 요구사항을 감당할 수 없음
- 해결책
  - 소프트웨어 공학
    - 품질 좋은 대규모 소프트웨어 시스템을 정해진 시간과 비용으로 개발하거나 발전시키는 체계적인 절차/방법론
    - 분석, 설계, 모델링, 구현, 테스트, 관리
- 분석과 설계의 필요성
  - 최적의 비용으로 협력해 목표하는 바를 이루려면, 정교한 분석과 설계 필요
  - 설계의 특징
    - 정답이 명확하지 않고, 좋은 설계를 찾기 어려움
    - 그림 작업이 많음(추상적임)
    - 반복, 시행 착오가 많음
    - 의사 소통이 중요
  - 설계의 목적
    - 생각, 이야기, 표현하기 위한 디자인
- 분석
  - 도메인 분석, 문제 정의, 요구 추출, 요구 분석, 요구 명세화 등
    - 고객의 문제를 SW적으로 해결하기 위해 고객의 비즈니스 환경과 문제, 문제를 해결하는 데 필요한 기술을 파악
    - What과 How를 명확히 분리하는 것이 중요함
      - 해결책(How) 보다는 **문제를 정의하는 것(What)**에 집중
- 설계
  - 쓸 수 있는 기술을 이용, 요구를 어떻게(HOW) 구현할 것인지 결정
    - 시스템 설계, 아키텍쳐, 상세 설계, 인터페이스 설계, 자료 설계
  - 구현 보다는 요구사항을 실현시키는 conceptual solution에 집중
- 모델링
  - 복잡한 SW를 바로 구현하는 것은 어려움
    - 동작과 구성을 도면도처럼 자세히 표현
    - 사용 사례 모델링, 정적 모델링, 동적 모델링
- 객체지향
  - 시스템이 객체로 구성되고, 관련된 객체 사이의 상호작용으로 동작
  - 현대 SW는 대부분 객체지향 방법론에 따라 개발
    - 보안이 중요한 은행, 군사 도메인 등 제외
    - 모듈화, 재사용성, 확장성, 유연성, 유지보수성 향상
  - 객체지향 분석
    - 문제 영역에서 개념을 객체로 표현하고 기술하는데 중점
  - 객체지향 설계
    - 객체들이 어떻게 협동하는지 중점

### Object-oriented Programming
- 객체지향 프로그래밍
  - 프로그램을 여러 객체라는 기본 단위로 나누고 객체 사이의 상호 작용으로 동작하는 것으로 인식하고 기술하는 방식
- 순차적/절차적 프로그래밍
  - ![image](https://github.com/googoo9918/TIL/assets/102513932/98e4a125-915b-4f97-b1f1-d53afcd88529)
  - 순차적(sequential)
    - 명시된 입력을 받아서 명시된 순서로 처리하고 순차적으로 결과를 냄
  - 절차적(procdural)
    - 프로그램을 여러 작은 함수(procedure)들의 단계적 호출로 구성
      - 단계의 절차가 아닌, 함수의 절차이므로 꼭 순차적이지 않을 수 있음
    - 큰 문제를 작은 문제로 나눠 접근(top-down)
    - 문제점
      - 데이터의 처리 방법만 구조화, 데이터 자체는 구조화 하지 못함
      - 데이터와 함수를 분리하여 생각, 관리가 어려움
      - 프로그램 규모가 커지면 함수들이 서로 얽혀 유지보수 어려움
        - 데이터 변경 되면 수정해야 하는 함수 많아짐
        - 함수나 호출 순서가 바뀌면 결과값에 변경이 있을 수 있음
- 객체지향 프로그래밍
  - 데이터와 함수를 하나의 덩어리로 묶어 생각
  - 작은 문제를 해결할 수 있는 객체를 만들고, 이 객체를 조합해 큰 문제를 해결(bottom-up)
  - 독립성/신뢰성이 높게 만들면 이후에 수정없이 재사용 가능
    - 생산성 대폭 향상
- 절차적 vs 객체지향
  - PP에서는 함수가 *계층적인 구조*를 이룸  
  - OOP는 클래스의 모임으로 이루어지고, *관계*로 표현
  - ![image](https://github.com/googoo9918/TIL/assets/102513932/ff8cfca3-c690-4e62-9e24-839f8ee25ea6)

### 객체
- 객체의 의미
  - 어떠한 상태 값과 행위를 갖고 있는 데이터
- 절차지향적으로 객체 구성 시
  - 상태는 구조체로 표현
  - 행위는 구조체로 표현된 상태를 입력으로 받는 함수로 표현
  - 즉, **데이터와 함수가 분리**되어 있음
- 객체지향에서 객체
  - 데이터(상태)와 행위를 하나로 묶어서 관리
    - 캡슐화
- 클래스
  - 동일한 속성과 행위를 수행하는 객체의 집합
    - 클래스는 데이터 타입으로 인식하기도 함
  - 즉, 객체는 클래스의 인스턴스임
- 인스턴스 변수 vs 클래스 변수
  - 인스턴스 변수
    - 필드 변수, 각 인스턴스에 존재하는 데이터를 저장하기 위한 변수
    - 클래스 내에 선언되는 변수, 객체 생성 시마다 *매번 새로운 변수 생성*
    - 다른 객체와 공유하지 않음
  - 클래스 변수
    - 클래스에 속하는 객체들이 공유할 수 있도록 해주는 변수
    - static으로 선언, 처음 딱 한 번만 생성됨
  - 메모리 생성 위치
```java
public class StaticTest{
    static int classvar = 10;
    int instance var;
    public void method(){
        int localVar = -100;
    }
}
```
  - ![image](https://github.com/googoo9918/TIL/assets/102513932/e34d5701-2c5a-4b80-aa3a-b6d35ac054d5)
  - static method 사용 시 주의 사항
    - static method는 오직 클래스 변수로만 접근 가능(인스턴스 변수를 사용하지 못함)
      - static method도 클래스 변수와 로드되는 시점이 동일
      - 따라서 객체가 생성되지 않은 상황에서도 변수를 사용할 수 있어야 함(인스턴스 변수는 아직 생성되지 않음)
    - this 키워드 사용 불가
      - this는 호출 당시 실행 중인 객체를 가리키는 레퍼런스
      - static method는 객체가 생성되지 않은 상황에서 호출이 되어야 함
    - 클래스 변수가 필요한 이유
      - 클래스 안에 정의한 메서드에 의해 널리 사용되는 디폴트/상수 값
      - 그 외 전역변수로 사용히 필요할 경우
        - 캡슐화의 우너칙에 예외 이므로, 무분별히 남발하지 말 것
- 변수 vs 객체
  - 변수는 객체를 가리키는 nametag(reference)
  - 특정 시점에 객체를 담고 있을 수도, 아닐 수도 있음
  - 한 객체는 여러 변수에 의해 가리켜질 수도 있음
  - 하나의 변수가 다른 객체를 가리킬 수도 있음
- 오퍼레이션 vs 메서드
  - 오퍼레이션
    - 수행되어야 할 연산을 추상화 한 것
      - 행위가 어떻게 구성 되는지 선언만 하고 내부 구현은 신경 쓰지 않음
    - 특정 클래스에서 operation의 구현체

### 추상화
- 사물의 중요한 특징에 집중, 덜 중요한 상세 사항은 가려냄
  - 공통된 특징은 올리고, 세부사항은 감춤
  - ex) 리모컨으로 tv 조작 시 -> 사용자는 버튼을 누를 뿐, 어떤 동작이 이뤄지는지는 모름
  - ex2) 자료구조에서 추상 자료형을 생각할 시
    - 사용자는 사용에 집중
    - 구현자는 구현에 집중
  - ex3) 사람 객체를 모델링 할 때
    - 상황에 따라 필요한 것만 선별하여 속성/행동을 추려냄
    - 여러 종류의 사람의 공통 개념적 특정을 묶어 한 단계 높은 추상화를 할 수 있음
- 데이터 추상화
  - 여러 자료형을 하나로 묶어 더 높은 단계로 추상화 함
    - ex) 일반화
- 프로시저 추상화
  - 함수를 어떻게 호출하고, 무엇을 수행하는지만 알게 하고 함수 내부 자세한 사항(구현)은 감춤
- 추상화는 디자인의 중요 원칙임
  - 설계 시 추상적인 계약(요구사항, 인터페이스)을 실제 구현된 구체적인 부분(클래스, 모듈)과 분리하여 설계
  - What과 How를 분리
  - 고수준의 전체 아키텍쳐를 고려, 이후에 저수준의 구현 세부 사항을 다룸

### 캡슐화
- 캡슐화
  - 변수와 메소드를 캡슐로 감싸는 개념
    - 데이터와 행위를 클래스 안으로 *숨김*
    - black box로서 input/output과 연계된 interface만 공개하고, **내부 구체 사항은 감춤** (추상화)
      - 사용자가 알 필요 없는 정보는 외부에서 접근하지 못하도록 제한(정보 은닉)
- 캡슐화 정보 은닉 예시
  - 클래스로 데이터와 함수를 묶음
  - 데이터는 외부에서 접근 할 수 없게 하고, 개발자가 허락한 함수만 사용하게 함
    - 데이터를 보호함으로써 의도치 않은 동작을 방지할 수 있음
- 응집도(cohesion)
  - 클래스 안 요소들이 얼마나 밀접하게 관련되어 있는지
- 결합도(coupling)
  - 어떤 기능을 실행하는 데 다른 클래스에 얼마나 의존적인지
- 높은 응집도와 낮은 결합도를 유지해야 요구사항 변경에 유연하게 대처 가능
  - ![image](https://github.com/googoo9918/TIL/assets/102513932/8b795190-1f50-4fe7-9260-3c5ebe9c1967)
  - 캡슐화는 정보 은닉을 통해 높은 응집도, 낮은 결합도를 갖도록 도와줌
- 예시
  - ![image](https://github.com/googoo9918/TIL/assets/102513932/50db5e61-b6e7-49f5-8e55-6c91fc3cf0d6)

### 상속
- 일반화의 의미
  - 여러 개체들이 가진 공통된 특성을 부각, 하나의 개념으로 성립시키는 과정(추상화)
  - OOP에서는 여러 개의 서브 클래스로부터 공통점을 찾아내고, 하나의 슈퍼 클래스를 도출하는 과정을 의미
- 상속
  - 슈퍼 클래스에 정의한 변수와 메서드를 서브 클래스가 묵시적으로 소유하도록 함
    - 공통 속성, 메서드를 반복적으로 정의하지 않아도 됨
- IS`-`A 관계
  - An A is a kind of B가 성립하면 A는 B의 일종이다로 해석, A 클래스가 B의 서브 클래스가 될 수 있음
    - Rectangle은 Shape의 일종
    - Shape은 Rectangle의 일종
- 메서드 오버라이딩
  - 슈퍼클래스에 정의된 메서드를 서브클래스에서 재정의
  - 이름은 공유, 각 서브 클래스의 맥락에 맞게 내용을 바꿀 수 있음
  - 주의
    - `Person person = new Student()`의 경우
    - Person 타입 참조를 갖지만, 실제로 가리키는 객체는 Student 타입임
      - 오버라이드 하였다면 Student의 메서드가 실행, 안했다면 Person의 메서드가 실행됨

### 다형성
- Poly(many) + morphism(form)
  - 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질
  - ![image](https://github.com/googoo9918/TIL/assets/102513932/88b01e5f-9e40-4248-85a4-b3a01542f074)
- 장점
  - 코드를 간결히 표현
  - 변경 사항에 유연히 대처
- 추상 클래스(abstract class)
  - render 오퍼레이션 구현 방법이 다 달라, render의 구현을 슈퍼 클래스인 HTMLElement에서 할 수 없음
  - 오퍼레이션만 정의하는 것을 가상 함수 또는 추상 메서드라 지칭
  - HTMLElement을 추상 클래스라 지칭함
- 추상 클래스 특징
  - 추상 메서드를 갖는 클래스는 추상 클래스로 선언해야 함
  - 동작이 정의되어 있지 않아 객체를 생성할 수 없음
  - 상속을 받은 서브 클래스는 추상 메서드를 오버라이딩 해서 구현해야 함

### 정리
![image](https://github.com/googoo9918/TIL/assets/102513932/7339b748-7525-42b9-bf49-a52c6752f6e6)

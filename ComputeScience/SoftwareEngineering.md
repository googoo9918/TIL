## 목차
- [소프트웨어공학](#소프트웨어공학)
  - [1. SW Engineering](#1-sw-engineering)
  - [2. Software Crisis](#2-software-crisis)
  - [3. Separation of Concerns, Abstraction, Modularity](#3-separation-of-concerns-abstraction-modularity)
  - [4. SWEBOK](#4-swebok)
  - [5. Requirement Engineering](#5-requirement-engineering)
  - [6. Scrum](#6-scrum)
  - [7. Product Backlog Item](#7-product-backlog-item)
  - [8. SRS(Software Requirements Specification)](#8-srssoftware-requirements-specification)
  - [9. Relationships in Use Case Diagram](#9-relationships-in-use-case-diagram)
  - [10. Relationship between classes](#10-relationship-between-classes)
  - [11. SOLID](#11-solid)
  - [12. SEQUENCE DIAGRAM에 대한 설명으로 틀린 것은?](#12-sequence-diagram에-대한-설명으로-틀린-것은)
  - [13. XP에 대한 설명으로 틀린 것은?](#13-xp에-대한-설명으로-틀린-것은)
  - [14. 유스케이스 구성요소간의 관계에 포함되지 않는 것은?](#14-유스케이스-구성요소간의-관계에-포함되지-않는-것은)
  - [15. 요구사항 분석에서 비기능적(Nonfunctional) 요구에 대한 설명으로 옳은 것은?](#15-요구사항-분석에서-비기능적nonfunctional-요구에-대한-설명으로-옳은-것은)
  - [16. 객체지향 개념에서 다형성(Polymorphism)과 관련된 설명으로 틀린 것은?](#16-객체지향-개념에서-다형성polymorphism과-관련된-설명으로-틀린-것은)
  - [17. 속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것을 의미하는 객체지향 개념은?](#17-속성과-관련된-연산operation을-클래스-안에-묶어서-하나로-취급하는-것을-의미하는-객체지향-개념은)
  - [18. 애자일(Agile) 프로세스 모델에 대한 설명으로 틀린 것은?](#18-애자일agile-프로세스-모델에-대한-설명으로-틀린-것은)
  - [19. Gof(Ganf og Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?](#19-gofganf-og-four-디자인-패턴을-생성-구조-행동-패턴의-세-그룹으로-분류할-때-구조-패턴이-아닌-것은)
  - [20. 소프트웨어 모델링과 관련한 설명으로 틀린 것은?](#20-소프트웨어-모델링과-관련한-설명으로-틀린-것은)
  - [21. 유스케이스 다이어그램에 관련된 내용으로 틀린 것은?](#21-유스케이스-다이어그램에-관련된-내용으로-틀린-것은)
  - [22. Use Case Diagram에 대해 설명하시오(과제 기반)](#22-use-case-diagram에-대해-설명하시오과제-기반)
  - [23. Draw a Class Diagram + Define their relationships ansd their cardinalities](#23-draw-a-class-diagram--define-their-relationships-ansd-their-cardinalities)
  - [24. Sequence Diagram의 상호 작용 연산자에 대해 설명하라](#24-sequence-diagram의-상호-작용-연산자에-대해-설명하라)
  - [25. Activity Diagram의 key elements는 무엇인가? 최소한 5개 이상 설명하라](#25-activity-diagram의-key-elements는-무엇인가-최소한-5개-이상-설명하라)
# 소프트웨어공학
## 1. SW Engineering
- 소프트웨어 엔지니어링은 컴퓨터 소프트웨어를 개발, 운영 및 유지 관리하기 위한 체계적이고 정형화된 접근 방법을 연구하는 것
  - 소프트에어의 품질, 안정성, 효율성 및 사용성을 높이기 위해 다양한 원칙, 방법론 및 도구를 사용함
- 과정
  - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 배포 -> 유지 보수
- 방법론
  - 폭포수 모델, 반복적 개발, 애자일 방법론 등이 있음
- 중요 원칙 및 개념
  - 모듈화, 추상화, 정보 은닉, 재사용성
## 2. Software Crisis
- 1960년대부터 1970년대에 걸쳐 소프트웨어 개발 프로젝트들이 점점 더 복잡해지고 커지면서 발생한 일련의 문제를 설명하는 용어로, 예산 초과, 일정 지연, 품질 저하 등의 문제가 있음
- 주요 원인
  - 복잡성 증가로 인한 개발 및 유지 보수 어려워짐
  - 요구사항 변경
    - 사용자 요구사항의 변경으로 개발 일정이 불안정해짐
  - 품질 부족
    - 테스트와 검증 과정이 미비하여 출시된 소프트웨어의 품질이 낮았음
  - 생산성 부족
    - 개발 도구와 방법론의 미흡으로 개발자들의 생산성이 저하됨
- 이를 해결하기 위해 소프트웨어 공학 분야가 탄생하게 됨
  - 소프트웨어 개발 프로세스를 체계적이고 표준화된 접근 방식으로 관리함
    - 개발 프로세스 표준화, 모듈화 및 추상화, 요구사항 관리, 소프트웨어 테스트, 프로젝트 관리 및 협업 도구, 개발 도구 및 환경 개선
## 3. Separation of Concerns, Abstraction, Modularity
- 관심사의 분리
  - 관심사의 분리는 소프트웨어 설계 및 개발에서 다양한 기능과 책임을 독립적인 부분으로 분리하는 원칙임
  - 이 원칙을 따르면 각 부분은 자신의 책임에만 집중하여 다른 부분과의 상호 작용은 최소화됨
  - 이로 인해 소프트웨어의 가독성, 유지 보수성 및 확장성을 향상 가능함
- 추상화
  - 추상화는 복잡한 시스템이나 개체를 단순한 개념으로 표현하는 과정
  - 추상화를 통해 개발자들은 복잡한 세부 사항을 숨기고 시스템의 주요 기능에만 초점을 맞출 수 있음
  - 이를 통해 문제를 더 쉽게 이해하고 해결할 수 있으며, 재사용 가능한 구성 요소를 만들 수 있음
- 모듈화
  - 소프트웨어를 작은, 독립적인 모듈로 분리하는 원칙
  - 각 모듈은 독립적으로 개발, 테스트 및 유지보수가 가능함
  - 다른 모듈과 명확하게 정의된 인터페이스를 통해 상호 작용함
  - 모듈화를 통해 시스템의 복잡성을 관리할 수 있고, 개발 프로세스의 효율성을 높일 수 있음
  - 모듈화를 통해 재사용성을 높이고, 변경이 발생할 때 영향을 최소화할 수 있음
## 4. SWEBOK
- SoftWare Engineering Body of Knowledge
  - 소프트웨어 엔지니어링의 기초가 되는 지식과 원칙들을 체계화하고 문서화한 참고 자료
  - IEEE Computer Society와 ISO/IEC JTC 1이 공동으로 개발
  - 소프트웨어 엔지니어들이 소프트웨어 개발 프로젝트를 수행하는데 필요한 지식과 기술을 제공함
  - 이를 통해 자신의 지식과 기술을 객관적으로 평가하고, 필요한 경우 개선할 수 있는 기회를 얻을 수 있음
- 핵심 지식 영역
  - 소프트웨어 요구사항: 사용자 요구사항 수집, 분석, 문서화 및 검증에 대한 지식과 기술 제공
  - 소프트웨어 설계: 소프트웨어 구조, 구성 요소, 인터페이스, 데이터 모델 등을 설계하는 지식과 기술을 제공함
  - 소프트웨어 구현: 소프트웨어를 코딩, 테스트 및 디버깅 하는데 필요한 지식과 기술 제공
  - 소프트웨어 테스트: 소프트웨어의 품질을 평가하고, 결함을 발견 및 수정하는데 필요한 지식과 기술을 제공
  - 소프트웨어 유지 보수: 기능 추가, 수정, 최적화 및 문제 해결을 위한 지식과 기술을 제공
  - 소프트웨어 구성 관리: 소프트웨어 버전 관리, 협업, 빌드 및 배포를 위한 지식과 기술을 제공
  - 소프트웨어 엔지니어링 관리: 프로젝트 관리, 팀관리, 위험 관리 등 프로젝트를 지원하는 지식과 기술 제공
  - 소프트웨어 엔지니어링 프로세스: 소프트웨어 개발 프로세스를 계획 실행, 모니터링 및 개선하는 데 필요한 지식과 기술을 제공
  - 소프트웨어 엔지니어링 도구 및 방법론: 소프트웨어 개발 및 관리를 지원하는 다양한 도구와 방법론에 대한 지식을 제공
  - 소프트웨어 품질: 소프트웨어 품질의 특성, 표준, 평가 방법 및 품질 관리 기법에 대한 지식 제공
  - 컴퓨팅의 전문적인 실무: 컴퓨터 과학, 프로그래밍 언어, 자료 구조, 알고리즘 등 소프트웨어 엔지니어링의 기초가 되는 컴퓨팅 지식 제공
  - 수학적 기초: 이산 수학, 확률 및 통계, 그래프 이론 등 소프트웨어 엔지니어링에 적용되는 수학적 원리 제공
  - 공학적 기초: 시스템 엔지니어링, 제어 이론, 전기 및 전자 공학 등 소프트웨어 엔지니어링과 관련된 공학 지식 제공

## 5. Requirement Engineering
- 소프트웨어 개발 프로세스의 초기 단계
  - 시스템이 충족해야 하는 사용자 요구사항과 기능적, 비기능적 요구사항을 식별, 분석, 문서화 및 검증하는 일련의 활동을 포함함
- 주요 활동
  - 요구사항 수집
  - 요구사항 분석
  - 요구사항 명세
  - 요구사항 검증
  - 요구사항 관리
## 6. Scrum
- 애자일 소프트웨어 개발 방법론 중 하나
- 프로젝트를 가볍고 유연하게 관리하면서 빠르게 변화하는 요구사항에 대응할 수 있는 방식
- Scrum은 제품 개발에 소규모의 교차 기능 팀을 사용, 짧은 개발 주기를 통해 지속적으로 개선하고 높은 가치를 창출하는 제품을 개발함
- 고객의 요구사항에 신속하게 대응하고 팀의 생산성을 높이며 프로젝트의 투명성을 제공하는 데 초점을 맞춤
- 주요 구성 요소와 원칙
  - Scrum 팀: 제품 개발에 참여하는 교차 기능을 가진 소규모 팀
    - 제품 소유자, 스크럼 마스터, 개발 팀이 포함됨
  - 제품 백로그: 제품 백로그는 개발이 필요한 모든 기능, 기술 작업, 버그 수정 등을 포함하는 우선 순위가 지정된 목록임
    - 제품 소유자는 제품 백로그를 관리하고 가치와 우선순위를 결정함
  - 스프린트
    - 스프린트는 일정한 기간동안 진행되는 개발 주기
      - 각 스프린트 동안 팀은 제품 백로그에서 선택한 작업을 완료하여 즉시 출시 가능한 제품 증분(Product Increment)을 만듬
  - 스프린트 백로그
    - 특정 스프린트 동안 개발 팀이 수행할 작업을 포함하는 목록
      - 개발 팀과 제품 소유자가 함께 결정하며, 스프린트 동안 변경이 가능함
  - 일일 스크럼
    - 일일 스크럼은 매일 짧게 진행되는 회의로, 개발 팀이 진행 상황을 공유하고 문제를 식별하며 필요한 조치를 취함
  - 스프린트 검토
    - 스프린트가 종료될 때 진행되는 회의로, 개발팀이 완료한 작업을 시연하고 피드백을 받음
    - 이를 통해 제품 백로그를 업데이트하고 다음 스프린트의 목표를 설정함
  - 스프린트 회고
    - 스프린트가 끝난 후 개발팀이 자체적으로 회고하는 시간
      - 지난 스프린트의 성공 사례와 개선할 부분을 검토하여 지속적인 개선을 위한 행동 계획을 세움
## 7. Product Backlog Item
- 백로그는 개발해야 할 기능 또는 제품에서 요구하는 기능과 우선순위를 의미함
- Scrum의 제품 백로그에 있는 개별 항목으로, 제품이나 시스템에 추가하거나 개선해야 할 기능, 요구사항, 버그 수정, 기술 작업 등을 나타냄
  - 이러한 아이템들의 우선 순위가 지정된 목록으로 구성
  - 제품 소유자가 관리
- 특성
  - 독립적: 각 PBI는 다른 아이템과 독립적이어야 함(아이템들을 개별적으로 추정, 우선순위 지정 및 구현)
  - 협상 가능: PBI는 초기 단계에서 고정된 상세 내용이 아닌, 개발 팀과 제품 소유자 사이의 협상 대상이어야 함
  - 가치 있는(Valuable): PBI는 고객, 사용자 또는 조직에 가치를 제공해야 함
    - 제품 소유자는 PBI의 가치를 기준으로 우선순위를 결정함
  - 추정 가능(Estimable): 개발 팀은 PBI의 크기와 복잡성을 추정할 수 있어야 함
    - 이를 통해 스프린트 계획 및 제품 출시 일정을 결정
  - 작은 크기(Small): PBI는 한 스프린트 내에 완료할 수 있을 만큼 충분히 작아야 함
    - 큰 아이템은 작은 작업 단위로 분할되어야 함
  - 명확한 완료 기준(Testable): PBI는 완료 기준을 명확하게 정의해야 함
    - 개발 팀이 이를 확인할 수 있어야 함(이를 통해 품질 보장)  
## 8. SRS(Software Requirements Specification)
- 소프트웨어의 요구사항을 기록한 문서
  - 프로젝트에서 개발할 소프트웨어의 기능, 성능, 제약사항 등에 대한 상세한 명세를 포함함
  - 프로젝트의 이해관계자들(개발자, 고객, 사용자 등)에게 소프트웨어의 목표와 기대 결과물을 명확하게 전달하기 위함임
- 주요 목표
  - 소프트웨어의 명확한 목표, 품질 보장, 프로젝트 관리, 개발 리소스 추정
- 주요 내용
  - 개요: 프로젝트의 목적, 범위, 정의, 참조 문서 등을 포함
  - 전반적인 설명: 일반적인 기능, 사용자 그룹, 운영 환경, 인터페이스, 제약사항
  - 기능 요구사항: 수행해야 하는 기능을 입력, 처리, 출력등의 관점에서 명세
  - 비기능 요구사항: 성능, 신뢰성, 가용성, 보안 등과 같은 비기능적인 측면 기술
  - 용어 및 정의: 사용되는 용어와 약어에 대한 정의 제공
  - 참조문서
## 9. Relationships in Use Case Diagram
- ![image](https://user-images.githubusercontent.com/102513932/232038064-d6838168-0c3f-4b5a-91d8-5557cfad0ca1.png)
- 일반화
  - 행위자들 또는 유스케이스들 간의 상속 관계를 나타냄
    - 하위 행위자(또는 유스 케이스)가 상위 행위자(또는 유스 케이스)의 특성과 기능을 상속받음
    - 공통된 특성이나 기능을 상위 수준에서 정의하고 하위 수준의 행위자나 유스 케이스에 적용할 수 있음
    - 다이어그램의 복잡성을 줄이고 모델의 재사용성을 높임
  - 포함 관계(include)
    - 한 유스 케이스가 다른 유스 케이스의 일부 기능이나 작업을 표함하는 경우 사용됨
    - 기본 유스 케이스가 다른 유스케이스를 포함하게 됨
    - 중복되는 작업을 최소화하고 유스 케이스를 재사용할 수 있음
    - ex: 글을 등록한다 -> 로그인 한다
      - 글을 등록하기 위해서는 반드시 로그인을 해야함
  - 확장 관계(Extend)
    - 한 유스 케이스가 다른 유스 케이스를 확장하여 선택적인 동작이나 부가적인 기능을 추가할 때 사용됨
      - 조건부로 실행되며, 항상 실행되지 않음
    - 파일을 첨부한다 -> 글을 등록한다
      - 글을 등록할 때 선택적으로 파일을 첨부할 수 있음

## 10. Relationship between classes
- Dependency
  - ![image](https://user-images.githubusercontent.com/102513932/232039420-17d632ac-bc56-4049-9086-af6b8d2e180c.png)
    - 한 클래스가 다른 클래스의 기능이나 특성에 의존하는 경우
      - 한 클래스의 변경이 다른 클래스에 영향을 줄 수 있는 상황을 의미함
      - 주로 메서드의 매개변수나 로컬 변수로 다른 클래스의 인스턴스를 사용할 때 발생
- Association(연관 관계)
  - ![image](https://user-images.githubusercontent.com/102513932/232039012-5429132d-0091-4113-af0f-daa6c397277f.png)
  - 두 클래스가 서로 상호작용하거나 참조하는 경우
  - 관계의 방향과 다중성(ex: 1:1, 1:N, N:M)을 명시할 수 있음
- Aggregation(집합 관계)
  - ![image](https://user-images.githubusercontent.com/102513932/232039476-4ae68b78-aad4-4540-bd9f-512487ece60b.png)
  - 집합 관계는 전체 클래스와 부분 클래스 간의 관계를 나타냄
    - 전체 객체가 부분 객체를 포함하는 것을 의미함
    - 전체 클래스가 소멸되더라도 부분 클래스는 독립적으로 존재할 수 있음
- Composition
  - ![image](https://user-images.githubusercontent.com/102513932/232039556-0e5fd61f-f6c2-4618-9f9a-69beb0c6a90e.png)
  - 합성 관계는 전체 클래스와 부분 클래스 간의 강한 종속관계를 나타냄
    - 전체 객체가 소멸될 때 부분 객체도 함께 소멸됨(부분 클래스는 전체 클래스의 생명 주기에 종속적)
- Inheritance(Generalization)
  - ![image](https://user-images.githubusercontent.com/102513932/232039637-60d1118d-6067-46ab-92e4-eca22ad96f19.png)
  - 하위 클래스가 상위 클래스의 특성과 기능을 상속받는 경우
    - 코드 재사용과 객체 지향 프로그래밍의 다형성을 지원함
## 11. SOLID
- 객체지향 프로그래밍과 소프트웨어 설계에서 중요한 원칙 5가지를 나타내는 약어
  - 소프트웨어를 더 이해하기 쉽고, 유지보수하기 쉽고, 확장 가능하게 만드는 데 도움이 되는 설계 원칙
- 단일 책임 원칙(SRP(Single Responsibility Principle))
  - 각 클래스는 하나의 기능만을 담담해야 한다는 원칙
    - 클래스가 여러 기능을 담당하게 되면 한 기능을 수정할 때 다른 기능에 부작용이 발생할 가능성이 높아짐
    - 분리 시 유지 보수성과 코드의 가독성이 높아짐
- 개방-폐쇄 원칙(OCP(Open-Closed Principle))
  - 확장에는 열려 있고 수정에는 닫혀있어야 한다는 원칙
    - 기존 코드를 변경하지 않고도 기능을 추가할 수 있도록 설계해야 함
- 리스코프 치환 원칙(LSP(Liskov Substitution Principle))
  - 하위 클래스는 상위 클래스를 대체할 수 있어야 한다는 원칙
    - 하위 클래스는 상위 클래스의 모든 특성과 기능을 포함하고 있어야 함
    - 상위 클래스가 사용되는 곳에 하위 클래스를 사용해도 문제가 없어야 함
    - 상속을 사용할 때 코드의 안정성과 유연성을 높이는데 도움이 됨
-  인터페이스 분리 원칙(ISP(Intergface Segregation Principle))
   -  클래스가 자신이 사용하지 않는 인터페이스의 메서드에 의존하지 않아야 한다는 원칙
   -  인터페이스는 최소한의 메서드만을 포함 해야함
   -  인터페이스는 여러 작은 인터페이스로 나누어야 함
   -  클래스가 필요하지 않은 메서드를 구현하는 것을 방지함
   -  코드의 결합도를 낮춰 유지 보수성을 높임
-  의존성 역전 원칙(DIP(Dependency Inversion Principle))
   -  고수준의 클래스는 저수준의 클래스에 직접 의존하지 않아햐 함
   -  대신, 두 클래스는 추상화된 인터페이스나 추상 클래스를 통해 의존 관계를 형성해야 함
   -  소프트웨어 구조를 개선, 결합도를 낮춤, 모듈 간 의존성을 관리하는데 도움이 됨
## 12. SEQUENCE DIAGRAM에 대한 설명으로 틀린 것은?
- ![image](https://user-images.githubusercontent.com/102513932/232046629-17b0c4e5-04fd-49fb-a61b-531df16cdbc4.png)
- 객체 간 상호작용을 메시지 흐름으로 표현한 다이어그램
- 구성요소
  - 객체, 생명선, 실행, 메시지
- 객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것이다(O)
- 일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다(O)
- 회귀 메시지, 제어블록 등으로 구성된다(O)
- 주로 시스템의 **정적** 측면을 모델링하기 위해 사용한다 (X)
  - 동적임
## 13. XP에 대한 설명으로 틀린 것은?
- 애자일 개발 프로세스의 일종으로, 비즈니스 상의 요구가 시시각각 변동이심한 경우에 적합한 개발 방법
  - 비교적 적은 규모의 인원의 프로젝트에 적용하기 좋음
  - 개발 문서보다는 코드를, 조직적인 개발의 움직임 보다는 개개인이 책임과 용기에 중점을 둠
  - 빠른 시간안에 전달을 목적으로 함
  - 테스트 코드를 작성하도록 하며, 테스트를 기반으로 프로젝트를 완성시켜 나가도록 함
  - 반복적으로 프로토 타입을 고객에 전달함으로써 고객의 요구사항 변화에 민첩하게 대응함
- 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다(O)
- 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다(O)
- 구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스코드에 중점을 둔다(O)
- 대표적인 **구조적** 방법론 중 하나이다(X)
  - 구조적(단계별) 방법론에 반대되는 애자일 방법론임
## 14. 유스케이스 구성요소간의 관계에 포함되지 않는 것은?
- 연관(O)(Association)
- 확장(O)(Extend)
- **구체화**(X)
- 일반화(O)(Generalization)
- 포함(O)(include)
## 15. 요구사항 분석에서 비기능적(Nonfunctional) 요구에 대한 설명으로 옳은 것은?
- 비기능적 요구사항: 성능, 신뢰성, 가용성, 보안에 대한 내용
- 시스템의 처리량, 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다(X)
- 차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다는 비기능적 요구이다(O)
- 시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다(X)
- 금융 시스템은 조회, 인출, 입금, 송금의 기능이 있어야 한다는 비기능적 요구이다(X)
  - 기능적 요구임
## 16. 객체지향 개념에서 다형성(Polymorphism)과 관련된 설명으로 틀린 것은?
- 다형성은 객체들이 다른 클래스에 속할 수 있음에도 불구하고 동일한 인터페이스를 갖고 있는 것을 말함
  - 다형성은 코딩의 유연성과 확장성을 높여주고, 코드 재사용성을 증가시킴
  - 메서드 오버로딩, 오버라이딩, 인터페이스와 추상 클래스등이 있음
- 다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다(O)
- 다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다(O)
- 메소드 오버라이딩은 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 무시하고 재정의할 수 있다(O)
- 메소드 오버로딩의 경우 **매개 변수 타입은 동일**하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있다(X)
  - 매개변수의 타입과 갯수를 다르게 해서 구분한다
## 17. 속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것을 의미하는 객체지향 개념은?
- Inheritance(상속)
- Class
- Encapsulation(캡슐화)
- Assocation(연관)
## 18. 애자일(Agile) 프로세스 모델에 대한 설명으로 틀린 것은?
- 빠른 변화에 대응하고 끊임없이 개선하는 방식의 개발 프로세스
  - 워터폴 개발 방식의 단점을 극복하기 위해 제안
    - 워터폴 방식은 개발 과정을 순차적으로 진행하며 각 단계가 완료되어야 다음 단계로 진행할 수 있는 방식임
    - 개발 시간이 길고 변경이 어려움
- 핵심 원칙
  - 고객 참여, 짧은 개발 주기를 통한 반복적인 개발, 요구사항에 유연하게 대응하는 적응성, 능동적으로 동작하는 자기 조작화 개발 팀
  - ex) 스크럼, 익스트림 프로그래밍(XP), 칸반(Kanban)
- 변화에 대한 대응보다는 **자세한 계획**을 중심으로 소프트웨어를 개발한다(X)
  - 구조적 방법론에 대한 설명이다.
- 프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다(O)
- 협상과 계약보다는 고객과의 협력을 중시한다(O)
- 문서 중심이 아닌, 실행 가능한 소프트웨어를 중시한다(O)
## 19. Gof(Ganf og Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?
- 생성 과정은 객체의 생성 과정에 관여, 구조 패턴은 객체의 합성에 관여, 행동 패턴은 객체가 상호작용하는 방법이나 관심사를 분리하는 방법에 관여함
- 생성(추상 팩토리(Abstract Factory), 빌더(Builder), 팩토리 메소드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton))
- 구조(어댑터(Adapter), 브릿지(Bridge), 컴포지트(Compostie), 데코레이터(Decorator), 퍼싸드(Facade), 플라이웨이트(Flyweight), 프록시(Proxy))
- 행위(책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(InterPreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor))
- Adapter 패턴
- Bridge 패턴
- Builder 패턴
  - 생성 패턴임
- Proxy 패턴
## 20. 소프트웨어 모델링과 관련한 설명으로 틀린 것은?
- 소프트웨어 모델링은 소프트웨어 개발 과정에서 시스템의 구조, 행위, 기능, 그리고 비즈니스 프로세스 등을 시각화,명세화, 문서화하는 과정
  - 시스템을 이해하고 분석하는 데 도움이 되고, 개발자와 이해관계자들 간의 의사소통을 원할하게 하며, 소프트웨어의 품질과 정확성을 높임
- 모델링 기법
  - 통합 모델링 언어(UML): 소프트웨어 시스템을 시각화하고 문서화하기 위한 표준 모델링 언어
    - 클래스 다이어그램, 객체 다이어그램, 시퀀스 다이어그램, 상태 다이어그램
  - 데이터 모델링(Data Modeling): 데이터베이스의 구조를 설계하고 관리하는데 사용되는 기법
    - 개체-관계 다이어그램(Entity-Relationship Diagram, ERD)
  - 프로세스 모델링: 비즈니스 프로세스나 소프트웨어의 작동 원리를 표현하는 데 사용되는 기법
    - 흐름도(Flowchart), 유즈케이스 다이어그램(Use Case Diagram), 활동 다이어그램(Activity Diagram)등을 사용
  - 아키텍쳐 모델링(Architecture Modeling): 소프트웨어의 전체 구조와 각 구성요소 간의 관계를 포함하는 데 사용되는 기법
    - 컴포넌트 다이어그램(Component Diagram), 배포 다이어그램(Deployment Diagram), 패키지 다이어그램(Package Diagram)등 사용 
- 모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없다(X)
- 구조적 방법론에서는 DFD, DD(Data Dictionary)등을 사용하여 요구사항의 결과를 표현한다.
- 객체지향 방법론에서는 UML 표기법을 사용한다.
- 소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 된다.
## 21. 유스케이스 다이어그램에 관련된 내용으로 틀린 것은?
- 시스템과 상호작용하는 외부시스템은 액터로 파악해서는 안된다(X)
- 유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다.(O)
- 시스탬 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다.(O)
- 액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다.(O)
  - 사용자가 인식할 수 없는 시스템 내부의 기능을 유스케이스로 취급해서는 안됨
## 22. Use Case Diagram에 대해 설명하시오(과제 기반)
- 유스케이스 다이어그램은 소프트웨어 시스템이 사용자에게 제공하는 기능이나 서비스를 기술한 것으로, 시스템의 요구사항을 사용자 중심으로 표현함
- 액터는 시스템과 상호작용하는 사용자나 다른 시스템 혹은 장치를 나타냄
  - Active Actor는 active as Trigger
  - Passive Actor는 주로 Data를 받아 다른 작업을 수행하는 External System
- Identifying Actors
  - 누가/무엇이 시스템을 사용하는가
  - 상호작용 시 역할이 무엇인가
  - 누가 시스템과 정보를 주고받는가
  - 어떤 다른 시스템과 상호작용하는가
  - 누가 시스템을 시작하고, 종료하며 유지하는가
- 유스케이스는 시스템이 수행하는 기능을 표현함
  - ![image](https://user-images.githubusercontent.com/102513932/232078538-d6600940-4998-4829-816f-df21b790b5e4.png)
  - Verb Form으로 표현, 
  - 기능 관점에서 도출해야 하고, data를 조작하는 function을 확인할 것
    - CRUD base
- Finding Use Case
  - actor가 system에 원하는 기능은?
  - 어떤 정보로 CRUD를 할 것인지?
  - 변경 사항, 유지보수?
- 관계 참고 : - [9. Relationships in Use Case Diagram](#9-relationships-in-use-case-diagram)
  - Generalization(일반화), Inculude, Extend
## 23. Draw a Class Diagram + Define their relationships ansd their cardinalities
- 참고 [10. Relationship between classes](#10-relationship-between-classes)
- 기반 관계
  - Dependency(의존 관계)
    - ex) A 클래스가 B의 클래스의 기능을 사용해 데이터를 조회한다 가정
      - A는 B클래스에 의존함 
  - Association(연관 관계)
    - 1:N, N:M, 1:1 등 연관 관계
  - Aggregation(집합 관계)
    - '부서' 클래스와 '교수' 클래스가 있을 때, 부서 클래스는 여러 명의 교수를 포함할 수 있지만, 교수는 부서와 독립적으로 존재할 수 있음
  - Composition
    - 'car' 클래스와 'Engine' 클래스가 있을 때, 'Car'는 'Engine'을 포함하며, 'Engine'의 수명 주기는 'Car'에 종속되어 있음
  - Inheritance
    - 'Animal' 클래스가 있고, 'Dog' 클래스와 'Cat' 클래스가 'Animal' 클래스의 속성과 메서드를 상속 받을 시
## 24. Sequence Diagram의 상호 작용 연산자에 대해 설명하라
- 시퀀스 다이어그램에서 상호작용 연산자는 여러 메시지 흐름 사이에 조건 또는 병렬 실행을 표현하는 데 사용됨
- alt(Alternative)
  - 조건부 상호작용을 나타냄
  - 두 개 이상의 메시지 흐름 중 하나를 선택적으로 실행하는 경우 사용
  - if-else 구문과 유사하게 동작
- opt
  - 선택적 상호작용을 나타냄
  - 특정 조건이 충족될 때만 메시지 흐름이 실행
  - if 구문과 유사하게 작동
    - 조건이 참인 경우에만 메시지 흐름이 실행
- par
  - 병렬 상호작용
  - 여러 메시지 흐름이 동시에 실행되는 경우 사용
  - 동시성을 표현하며, 각 메시지 흐름이 독립적으로 실행됨
- loop
  - 특정 조건이 만족되는 동안 메시지 흐름이 반복적으로 실행
- break
  - 특정 조건이 충족될 때 메시지 흐름을 중단
- critical
  - 여러 메시지 흐름 중 한 번에 하나의 메시지 흐름만 실행되어야 하는 경우 사용
  - 동기화를 표현, 한 메시지 흐름이 실행되는 동안 다른 메시지 흐름은 대기 상태
- ignore
  - 특정 조건이 충족되지 않는 경우, 메시지 흐름을 무시하는 경우 사용

## 25. Activity Diagram의 key elements는 무엇인가? 최소한 5개 이상 설명하라
- 액티비티 다이어그램은 UML의 행위 다이어그램 중 하나로, 시스템의 작업 흐름이나 비즈니스 프로세스를 시각화하는 데 사용됨
- 주요 요소
  - Activity(액티비티): 작업이나 단계를 나타냄
    - 사각형 모양의 둥근 모서리로 표시됨
    - ![image](https://user-images.githubusercontent.com/102513932/232092579-948a7923-c3be-4500-86f9-6bd8c6636b3f.png)
  - Initial Node(초기 노드): 액티비티 다이어그램의 시작점을 나타내는 노드
    - 작은 검은 원으로 표시됨
    - ![image](https://user-images.githubusercontent.com/102513932/232092775-b65d78c4-4f75-4190-97f3-a4ac2cf8fe3a.png)
  - Final Node(종료 노드): 액티비티 다이어그램의 종료점을 나타내는 노드
    - 큰 원 안에 작은 검은 원으로 표시됨
    - ![image](https://user-images.githubusercontent.com/102513932/232092956-d38ece23-9e3c-4d85-8487-b8fab4dd7322.png)
  - Control Flow(제어 흐름)
    - 액티비티 간의 전환을 나타냄
    - 화살표로 표시
    - ![image](https://user-images.githubusercontent.com/102513932/232093117-bd42a9f6-a3dc-400a-b9cb-e2f20b680c4b.png)
  - Decision Node(결정 노드)
    - 조건에 따라 흐름이 나뉘는 지점을 나타냄(if-else)
    - 마름모 모양으로 표시
    - ![image](https://user-images.githubusercontent.com/102513932/232093289-b60a5d8b-1cf2-47a8-8cce-5c7eaa7adb85.png)
  - Merge Node(병합 노드)
    - 여러 개의 흐름이 하나의 흐름으로 합쳐지는 지점을 나타냄
    - 마름모 모양으로 표시
    - 결정 노드와 반대로 작동, 여러 분기를 다시 하나의 흐름으로 합침
    - ![image](https://user-images.githubusercontent.com/102513932/232093512-a0cca66f-5cad-4c1f-95fb-3eb279974e89.png)
  - Fork Node(분기 노드)
    - 하나의 흐름이 병렬로 나뉘는 지점을 나타냄(병렬 처리를 나타냄)
    - 직선 모양의 바로 표시
    - ![image](https://user-images.githubusercontent.com/102513932/232093737-1164efd3-d03c-4faa-9a01-7134e5a9152a.png)
  - Object Node(객체 노드)
    - 액티비티에서 사용되는 데이터나 객체를 나타냄
    - 사각형으로 표시됨
    - ![image](https://user-images.githubusercontent.com/102513932/232094050-fafbb8a3-a2d8-4cdc-bcb8-0e5d94885656.png)




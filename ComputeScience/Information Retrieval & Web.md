## 웹서비스 아키텍처의 발전
### 웹 서비스 아키텍처(Stage 1)
- HTML + HTTP
  - HTML은 콘텐츠를 제공
  - HTTP는 콘텐츠를 전송
- 파일
  - 정적(Static)
    - 저장된 파일을 그대로 전송
  - 동적(Dynamic)
    - 입력 데이터를 바탕으로 실시간으로 HTML을 생성하여 전송
    - DBMS를 통해 데이터 조회, 이를 기반으로 HTML 페이지 생성
    - 클라이언트트 서버에서 받은 HTML 파싱 및 랜더링
      - HTML이 주로 사용, JS는 부가적으로 사용
  - 동기식(Synchronous)
    - 클라이언트는 서버로부터 응답을 받을 때까지 기다린 후 화면에 표시함 

### 웹 서비스 아키텍처(Stage 2)
- AJAX / Web 2.0
  - AJAX는 비동기적인 데이터 전송 방식을 가능하게 함
    - 웹 페이지의 일부만을 업데이트할 수 있도록 해줌
    - Web 2.0은 사용자 상호작용이 강화된 동적인 웹을 지칭
  - JSON(내용) + HTTP(전송)
    - 데이터 전송을 위해 HTML 대신 JSON 형식 사용
  - 웹 서버와 클라이언트 역할
    - 웹 서버는 클라이언트의 요청에 따라 JSON 형식의 데이터를 전송
    - 클라이언트는 수신한 JSON 데이터를 파싱, 렌더링하여 화면에 표시
    - JS가 주 역할, HTML은 보조 역할
  - 동적 콘텐츠의 DOM 조작
    - 클라이언트는 JSON 데이터를 통해 DOM(Document Object Model)을 직접 조작, 웹 페이지의 내용을 부분적으로 업데이트할 수 있음
      - 화면을 가공해서 표현할 수 있으며, 사용자에게 즉각적 반응 제공
  - 비동기 통신(Asynchronous)
    - 서버와의 상호작용을 필요할 때마다 처리, 페이지 전체를 다시 로드하지 않고 부분적 업데이트 가능
      - 사용자가 더 부드럽고 빠르게 웹 페이지와 상호작용

### 웹 서비스 아키텍쳐(Stage 3)
- JSON + HTTP
  - 여전히 JSON으로 데이터 전송, HTTP를 통함
- 양방향 통신(Bi-directional)
  - 웹 소켓을 이용, 클라이언트와 서버 간의 양방향 실시간 통신이 가능해짐
    - 연결이 유지된 상태에서 양방향으로 자유롭게 데이터 교환
    - HTTP처럼 요청-응답 구조 x
  - 실시간 통신(Real-time API)을 위해 Node.js같은 서버 기술 활용
    - Node.js는 비동기 처리를 기반으로 하기에, 실시간 처리가 필요한 웹 애플리케이션에 적합
      - 채팅, 주식거래 시스템과 같은 실시간 업데이트가 중요한 애플리케이션에서 주로 사용

### 자바스크립트(Javascript)
- jQuery.js
  - js 라이브러리, 브라우저 간의 호환성을 높이고, 독립성을 제공
    - 이를 통해 js 코드가 다양한 브라우저에서 일관되게 동작하도록 도와줌
- 웹표준(ECMAscript:ES)으로 채택
  - js는 ES 표준에 따라 발전해 왔고, ES6~9등의 버전으로 업데이트되었음
- HTML5(넓은 의미) = HTML5(좁은 의미) + CSS3 + ECMAscript(ES) + SVG(2D) + WebGL(3D)
  - 단순한 마크업 언어를 넘어, 다양한 웹 기술을 포함하는 광범위한 개념임
- 파편화 문제
  - 브라우저마다 지원하는 기능이 달라 Fragmentation 문제가 있었음
    - jQuery로 이러한 문제점 해결
- 프레임워크
  - Angular.js
    - 타임스크립트 사용, OOP와 DI 지원
  - React.js
    - 컴포넌트 기반, 뷰를 효율적으로 업데이트
  - Vue.js
    - React와 Angular의 장점을 결합한 구조 제공
  - 하이브리드 앱 프레임워크
    - 하나의 코드베이스로 ios와 android 동시 개발 가능
    - React Native
    - Flutter
      - Dart 언어 사용
- 브라우저 외부에서의 사용
  - 원래 브라우저에서만 실행되는 언어였으나
    - Node.js의 등장으로 서버나 스탠드얼론 환경에서도 사용 가능
    - Node.js는 js를 브라우저 밖에서 사용할 수 있는 서버 사이드 자바스크립트 런타임임
- 비동기 실행
  - 비동기 실행을 기본으로 지원
  - 독특한 특성

## 웹서비스 아키텍처의 구성
### 웹 아키텍처
- 1-티어
  - 웹 브라우저(HTTP 클라이언트) = 웹 서버(HTTP 서버)
- 2-티어
  - HTTP 클라이언트 - HTTP 서버/DB 클라이언트 - DB 서버
- 3-티어
  - HTTP 클라이언트 - HTTP 서버/WAS 클라이언트 - WAS서버/DB 클라이언트 - DB 서버
    - 클라이언트 요청 -> 웹 서버가 이를 WAS에 전달 -> WAS가 DB 서버에서 데이터를 가져와 응답
- 더 복잡해지면 n-티어
- 왜 티어를 나누는가?
  - 티어 분리를 통해 각 서버에 특화된 기능을 추가함
  - 0티어
    - Stand-alone 어플리캐이션, 클라이언트와 서버가 분리되지 않음
  - 1티어
    - 서버와 클라이언트 분리
    - 네트워크를 통해 서버와 통신
    - 정적 웹사이트 파일 제공이나, 간단한 API 요청에 응답하는 정도의 역할을 함
  - 2티어
    - DB 서버 분리
    - 클라이언트가 웹 서버를 통해 DB 서버에 접근
  - 3티어
    - WAS를 추가로 분리
      - 더 높은 확장, 보안, 안전성 제공
    - 분산 트랜잭션, 로드 밸런싱, 이중화, 동시성 제어 등 사용 가능
    - 비즈니스 로직 담당

### Static vs Dynamic 컨텐츠
#### Static vs. Dynamic 콘텐츠
- Static 콘텐츠
  - 미리 저장된 HTML 페이지를 그대로 클라이언트에 전송
  - 아파치 웹서버 or nginx
    - ex) http://abc.com/a.html
- Dynamic 콘텐츠
  - 사용자 요청에 따라 내용이 동적으로 생성
  - 프로그램 실행 -> DBMS 내용 검색 -> HTML로 변환하여 사용자에게 전송
  - 아파치 톰캣
    - ex) http:abc.com::8080/b.jsp
- 연동
  - 아파치가 받아서 톰캣에 넘겨주고 실행결과를 다시 아파치에게 넘겨줌
    - ex) http://abc.com/b.jsp
#### Static과 Dynamic 콘텐츠의 성능 차이
- 서버 부하
  - Dynamic 콘텐츠는 Static 콘텐츠에 비해 더 많은 서버 자원을 소모, 서버 부하 커질 수 있음
  - Dynamic 콘텐츠 요청이 많아질 수록 성능 저하 발생 가능
- 캐싱(Dynamic -> Static 컨텐츠화)
  - Dynamic 콘텐츠를 Static 콘텐츠로 변환하여 캐싱하면 성능을 향상시킬 수 있음
    - 서버 부하 감소 가능

#### Static과 Dynamic 콘텐츠 제공 과정
- Static 콘텐츠 제공
  - 웹 서버가 요청을 받아 HTML 파일 그대로 반환, 별도 연산이나 DB 접근 필요 x
- Dynamic 콘텐츠 제공 및 연동
  - 아파치와 같은 웹 서버가 요청 수신 후, 이를 웹 애플리케이션 서버 전달
  - 웹 애플리케이션 서버가 JSP, PHP 등의 동적 페이지 실행하여 HTML 생성 -> 아파치 서버로 반환 -> 클라이언트에게 전달

### 캐싱
- 브라우저 캐시
  - 브라우저는 방문한 웹 페이지의 자원(HTML,CSS,JS 등)을 로컬에 저장
  - 재방문 시 빠르게 페이지 로드가 가능하게 함
- 포워드 프록시
  - 클라이언트를 대신하여 서버에 요청을 전달
  - 다수의 클라이언트가 같은 자원 접근 시 해당 자원을 캐싱, 전송을 빠르게 함
  - 프록시 서버는 자주 요청되는 페이지나 자원을 캐싱, 같은 요청이 들어오면 자원을 제공하여 부하를 줄임
  - 주로 방화벽과 같은 개념으로 사용
- 리버스 프록시
  - 서버를 대신하여 클라이언트 요청을 받고, 서버에 전달
  - 서버의 앞단에서 클라이언트 요청을 받아 적절한 서버에 전달(로드 밸런싱), 서버 측에서의 캐싱을 담당하며 웹 서버의 부담을 줄임
  - 캐시된 콘텐츠가 없는 경우
    - 서버에서 직접 데이터를 받아와 클라이언트에게 전달
  - 캐시된 콘텐츠가 있는 경우
    - 서버에 접근하지 않고 직접 캐시된 데이터를 클라이언트에 응답
  - ex) nginx

### 로드밸런서
- 로드 밸런서
  - 동일 내용을 여러 시스템에 복제해서 구성 -> 외부에서 요청이 들어오면 여러 서버 중 하나로 라우팅하여 부하를 분산함
    - 가용성 증가, 성능 및 응답 속도 개선
- L4 스위치
  - 네트워크 계층에서 동작
  - TCP/UDP 프로토콜과 포트 정보를 기반으로 트래픽 분산
- L7 스위치
  - 애플리케이션 계층에서 동작
  - HTTP/HTTPS 요청의 헤더와 내용을 기반으로 트래픽 분산
    - URL, HTTP 메서드, 콘텐츠 종류 등 분석하여 분산 가능
    - 요청 내용을 세부적으로 분석할 수 있음 -> 세밀한 트래픽 관리 가능

### 방화벽/웹 방화벽/IDS/IPS
- 방화벽
  - 네트워크를 보호하기 위해 IP 주소와 포트 정보를 기반으로 인바운드/아웃바운드 트래픽을 필터링하고 통제 
  - DMZ
    - 방화벽 외부에 존재하는 영역, 인터넷에서 접근할 수 있도록 설정된 서버들이 있는 구역
    - 방화벽은 외부에서 내부 네트워크로 들어오는 트래픽에 대해 공인 IP와 사설 IP 주소 간의 변환을 관리
      - 외부 인터넷이 연결되어야 하면 공인 IP, 외부 인터넷 접근 시 공인 IP 공유 방식으로 사용 시 사설 IP 사용
      - 포트포워딩 사용
        - NAT의 한 형태, 포트 번호까지 지정하여 라우팅 제어
  - whilelist vs blacklist
    - 허용할 ip 주소/포트 --> 화이트리스트
    - 차단할 ip 주소/포트 --> 블랙리스트
- 웹 방화벽
  - 웹 애플리케이션 계층에서 발생하는 공격을 탐지하고 차단
  - SQL 인젝션, XSS등 공격 방어
- IDS(Intrusion Detection System)
  - 침입 탐지 시스템
    - 네트워크나 시스템에서 이상한 패턴 감지 -> 관리자에게 경고
    - 차단 기능은 없음
- IPS(Intrusion Prevention System)
  - 침임을 차단하는 시스템
    - 악성 트래픽을 실시간으로 차단

## 웹 서비스 아키텍처의 구성
### Apache Kafka
- 고성능 분산 메시징 시스템
  - 대규모 데이터 스트림 처리 + 큐잉, 일관성 및 안전성 보장
- 구성 요소
  - Producer
    - 메시지 생성 -> kafka로 전송
  - Consumer
    - Kafka에서 메시지를 읽어감
  - Broker
    - Kafka 서버 자체로, 메시지 저장 및 관리
- 주요 기능
  - 분산 메시징
    - 메시지 분산 저장 -> 가용성 높임
  - 스트리밍/버퍼링
    - 실시간 데이터 스트림 처리 및 저장
      - ex) 로그 집계, 헬스 체크, 실시간 모니터링
  - 이벤트 소싱
    - 데이터를 시간 순서대로 기록, 과거 이벤트 추적
- Kafka 도입 전후의 구조 변화
  - 도입 전
    - 여러 데이터 소스와 시스템 간 복잡한 연결이 필요했음
  - 도입 후
    - Kafka가 중간에 위치하여 중앙 메시지 허브 역할을 수행
      - 데이터 소스와 애플리케션이 Kafka만을 통해 통신
- 요약
  - 큐잉 서비스는 트래픽 과부하를 방지, 안전성을 높임
  - Apache Kafka는 이러한 큐잉 기능을 고성능으로 제공하는 분산 메시징 플랫폼
  - 대량의 실시간 데이터를 안정적으로 처리 가능 + 복잡한 시스템 간 데이터 흐름을 중앙 집중화하여 관리 가능
- Kafka의 토픽 개념
  - 토픽이란, Kafka에서 메시지를 카테고리별로 구분하는 논리적 단위임
    - ![image](https://github.com/user-attachments/assets/f2ef4879-2389-4772-980a-babd483567fa)
    - Producer는 메시지를 특정 토픽에 쓰고, Consumer는 특정 토픽에서 메시지를 읽음
  - 파티션
    - ![image](https://github.com/user-attachments/assets/8e0ac688-8a46-41e1-bb9b-8fc274e852f9)
    - 각 토픽은 여러 파티션으로 나뉘어 질 수 있으며, 파티션 내의 메시지들은 offset으로 구분되어 순서대로 저장됨
    - 파티션을 통해 토픽을 병렬로 처리할 수 있음
  - offset
    - 각 메시지는 파티션 내에서 고유의 offset을 가지며, 컨슈머는 이 오프셋을 통해 어떤 메시지까지 읽었는지 추적함
- Kafka의 파티셔닝
  - 각 토픽은 여러 파티션으로 구성될 수 있으며, 파티션이 많을 수록 데이터는 더 많은 브로커에 분산됨
  - ex)
    - 토픽이 3개의 파티션으로 구성된 경우, 프로듀서가 메시지를 쓰면 각 파티션에 메시지가 할당됨
    - 컨슈머는 각 파티션에서 메시지를 병렬로 읽을 수 있어 데이터 처리 성능이 높아짐
  - ex)
    - 토픽 A에 3개의 파티션이 있고, Kafka 클러스터에 3개의 Broker가 있다고 가정
    - 파티션 0은 브로커 1에, 파티션1은 브로커 2에, 파티션 2는 브로커3에 분산됨
    - 토픽 A의 데이터는 모든 브로커에 분선 저장, 브로커 장애가 발생해도 다른 브로커에서 파티션 복구 가능
    - 또한 각 Consumer는 서로 다른 파티션에서 메시지를 읽을 수 있음
      - 여러 컨슈머가 동시에 서로 다른 파티션을 병렬로 처리할 수 있게 됨
- Kafka 브로커 및 클러스터
  - ![image](https://github.com/user-attachments/assets/30009fae-a037-4f9f-8aad-cd838a01abdc)
    - 브로커
      - Kafka Broker는 데이터를 저장하고 관리하는 Kafka 서버
      - 여러 개의 브로커가 클러스터를 구성, 토픽과 파티션을 여러 브로커에 분산 저장하여 가용성과 확장성 보장
    - ZooKeeper
      - Kafka의 동작을 관리하고 저장
      - Kafka 클러스터의 브로커 간 메타데이터 관리
      - 브로커와 컨슈머 간의 상태를 조정
- Kafka 클러스터 예시
  - ![image](https://github.com/user-attachments/assets/52507511-2c2d-4551-94f6-d1e4c608e88d)
    - 각 파티션은 하나 이상의 브로커에 복제되어 저장
      - 이를 리프리카라 부름, 특정 브로커가 장애를 겪어도 데이터 손실 방지
    - 리더, 팔로워
      - 각 파티션은 리더와 팔로워로 구성
      - 리더는 모든 쓰기와 읽기 요청을 처리
        - 팔로워는 리더의 데이터를 복제함
        - 리더 브로커가 장애를 겪으면 팔로워가 리더 역할을 승계함
    - 컨슈머 그룹
      - 컨슈머 그룹 내의 각 컨슈머는 특정 파티션에서만 데이터를 읽어옴
      - 여러 컨슈머가 데이터를 병렬로 처리 가능
      - ex) Consumper Group A는 Topic Foo의 파티션 처리, Consumer Group B는 Topic Bar의 파티션 처리
- Kafka가 빠른 이유
  - 제로카피
    - Kafka는 데이터를 처리할 때, 메모리에서 데이터를 복사하지 않고 데이터의 주소를 복사하는 방식을 사용
    - 데이터 복사로 인한 오버헤드를 줄여 성능을 높임
  - 리눅스/BSD 커널 최적화
    - Kafka는 BSD 네트워크 커널의 mbuf를 직접 이용, 데이터를 복사하지 않고 포인터로 데이터를 참조함으로써 성능을 향상시킴
    - 데이터가 캡슐화되면서 발생하는 오버헤드를 줄임
- Kafka vs RabbitMQ/ActiveMQ 성능 비교
  - ![image](https://github.com/user-attachments/assets/8dcfaa6c-fae5-4b02-a37f-f7ff57305353)
    - Kafka의 성능
      - Kafka는 대량의 메시지를 안정적으로 처리 가능
      - 배치 크기를 늘릴 수록 처리 속도가 빨라짐
    - RqbbitMQ와 ActiveMQ
      - 상대적으로 낮은 메시지 처리량
        - 특히 대용량 데이터 처리 시
      - 실시간 처리 최적화
        - 실시간 메시지 전송에 강점을 지님

## HA(High Availability)
- HA(Hight Availability)
  - 고가용성
    - 노드 장애가 발생하더라도 서비스는 계속 운영할 수 있도록 만드는 기술
    - 데이터 복제와 장애 발생 시 자동 전환 등..
- 장애 상황에 따른 처리 방식
  - 슬레이브 노드 장애 시
    - 다른 슬레이브 운영 중이라면 서비스는 문제없이 동작
    - 새로운 슬레이브 생성 후 복제를 재개하면 그만
  - 마스터 노드 장애 시
    - 서비스가 중지될 수 있음
    - 슬레이브 노드 중 하나를 새로운 마스터로 승격하여 서비스 재개
    - 새로운 슬레이브를 설정하여 복제
- 고가용성 구성 방식
  - Active-Standby 구성
    - 하나의 액티브 노드와 그 노드를 대신할 스탠바이 노드로 구성
    - Active 노드가 장애를 겪으면 Standby 노드가 Active 노드로 승격
    - 새 Standby 노드를 설정, 두 개의 노드가 유지되도록 함
    - Standby에서 Active로의 전환이 느리면 문제 발생할 수 있음
  - Active-Active 구성
    - 한 Active 노드가 장애를 겪어도 다른 Active 노드가 운영을 이어감
  - Active-Active 구성의 합의
    - 여러 노드가 동시에 Active로 동작, 데이터 처리에 있어 의견 충돌이 발생할 수 있음
    - 합의 방식
      - 보통 홀수 개의 노드를 두어 과반수 합의를 이끌어냄.
        - MYSQL에서는 그룹 복제(Group Replication) 같은 방식으로 구현

### Apache Zookeeper
- ZooKeeper 개요
  - 기능
    - 분산 시스템의 노드 간 상태 정보를 공유
    - 장애 복구 및 데이터 일관성 유지
  - 필요성
    - Haddop 2.x에서는 추천 사항
    - Kafka에서는 필수
      - 이를 통해 클러스터 상태와 리더 선출 관리
- ZooKeeper 주요 특징
  - 고가용성
    - ZooKeeper는 분산 시스템의 고가용성을 보장하기 위해 설계됨
    - 단일 장애 지점(SPOF) 제거
      - 단일 장애 지점을 보완하여 시스템의 안정성을 높임
    - 리더 선출
      - 분산 시스템에서 리더 노드를 선출하고 관리
- ZooKepper 아키텍쳐
  - ![image](https://github.com/user-attachments/assets/873fe5d3-babb-47e2-8365-9fdb9e622fa5)
    - Leader
      - 쓰기 요청 처리, 시스템 변경 사항을 슬레이브 노드(Follwer)와 동기화
    - Follower
      - Leader 노드의 변경 사항을 복제, Leader가 장애를 겪을 시 새로운 Leader 선출
    - Clients
      - ZooKeeper 클러스터에 접근, 데이터를 읽거나 쓰는 역할 수행
- ZooKeeper의 구성 방식
  - Master/Slave 구성
  - Active / Stand-by
  - Active / Active
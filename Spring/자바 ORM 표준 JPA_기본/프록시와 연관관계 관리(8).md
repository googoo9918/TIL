## 프록시
- Member를 조회할 때 Team도 함께 조회해야 할까?
  - ![image](https://user-images.githubusercontent.com/102513932/200580271-56f47e45-6f9d-413f-b10f-17d9a8d9561a.png)
- 회원과 팀 함께 출력
  - ![image](https://user-images.githubusercontent.com/102513932/200580530-23c6e3d3-9905-4fe8-b8a9-ea0fbf3aeae6.png)
- 회원만 출력
  - ![image](https://user-images.githubusercontent.com/102513932/200580583-829b7234-90cb-42d9-9913-109c14e4d425.png)

### 프록시 기초
- `em.find()` vs `em.getReference()`
  - `em.find()` : 데이터베이스를 통해 실제 엔티티 객체 조회
  - `em.getReference()` : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
    - ![image](https://user-images.githubusercontent.com/102513932/200580923-8ddbee8e-6cb0-488e-93e1-62ecb5ed6aaf.png)

### 프록시 특징
- 실제 클래스를 상속 받아 만들어짐
- 실제 클래스와 겉 모양이 같음
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨
  - ![image](https://user-images.githubusercontent.com/102513932/200581107-4bb53ffd-596b-445a-85a2-7adb01d11ad3.png)
- 프록시 객체는 실제 객체의 참조(target)를 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메서드 호출
  - ![image](https://user-images.githubusercontent.com/102513932/200581320-b9a8430f-8695-4c42-b63b-42ced6aead42.png)

### 프록시 객체의 초기화
```java
Member member = em.getReference(Member.class, "id1");
member.getName();
```
- ![image](https://user-images.githubusercontent.com/102513932/200581500-bae1628b-dfde-4b57-b85a-9e003334eb58.png)

### 프록시의 특징
- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님
  - 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함
  - 비교 실패, 대신 instance of 사용
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `em.getReference()`를 호출해도 실제 엔티티 반환
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생
  - 하이버네이트는 org.hibernate.LazyInitializationException 예외 발생
### 프록시 확인
- 프록시 인스턴스의 초기화 여부 확인
  - `PersistenceUnitUtil.isLoaded(Object entity)`
- 프록시 클래스 확인 방법
  - `entity.getClass().getName()` 출력
    - ..javasist.. or HibernateProxy...
- 프록시 강제 초기화
  - `org.hibernate.Hibernate.initialize(entity);`
- 참고: JPA 표준은 강제 초기화 없음
  - 강제 호출: member.getName()
## 즉시 로딩과 지연 로딩
- Member를 조회할 때 Team도 함께 조회해야 할까?
  - 단순히 member 정보만 사용하는 비즈니스 로직
  - `println(member.getname());`
  - ![image](https://user-images.githubusercontent.com/102513932/200584051-931c557c-1f58-4cdd-9485-c761e342b352.png)
- 지연 로딩 LAZY를 사용해서 프록시로 조회
```java
@Entity
public class Member{
    @Id
    @GeneratedValue
    private Long id;

    @Column(name = "USERNAME")
    private String name;

    @ManyToOne(fetch = FetchType.LAZY) //**
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    ..
}
```
### 지연 로딩
- ![image](https://user-images.githubusercontent.com/102513932/200584854-5985c23c-f0e5-46e3-903d-94eec8058ed0.png)
- 지연 로딩 LAZY를 사용해서 프록시로 조회
  - ![image](https://user-images.githubusercontent.com/102513932/200584940-b44a2f60-8760-4d8a-865e-4eb2d0946b4c.png)
    - `Member member = em.find(Member.class,1L);`
  - ![image](https://user-images.githubusercontent.com/102513932/200585067-2e3d4181-9885-4083-ad08-0ef35b843aa3.png)
    ```java
    Team team = member.getTeam();
    team.getName(); //실제 team을 사용하는 시점에 초기화(DB 조회)
    ```
### Member와 Team을 자주 함께 사용 시
- ![image](https://user-images.githubusercontent.com/102513932/200585501-47774b24-710e-4359-b86a-8fed24a0c895.png)
- 즉시 로딩 EAGER를 사용해서 함께 조회
```java
@Entity
public class Member{

    @Id
    @GeneratedValue
    private Long id;

    @Column(name = "USERNAME")
    private String name;

    @ManyToOne(fetch = FetchType.EAGER) //**
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    ..
}
```
### 즉시 로딩
- ![image](https://user-images.githubusercontent.com/102513932/200585916-879c49a8-7eb5-4e4e-813f-3d604f8d83c8.png)
- 즉시 로딩(EAGER), Member 조회 시 항상 Team도 조회
  - ![image](https://user-images.githubusercontent.com/102513932/200586064-a5114fb0-ef0e-47d3-aaa5-526ae0c24be2.png)
  - JPA 구현체는 가능하면 조인을 사용해서 SQL 한 번에 함께 조회
## 프록시와 즉시로딩 주의
- **가급적 지연 로딩만 사용(특히 실무)**
- 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킴
- `@ManyToOne`, `@OneToOne`은 기본이 즉시 로딩 -> LAZY로 설정
- `@OneToMany`,`@ManyToMany`는 기본이 지연 로딩

### 지연 로딩 활용
- Member와 Team은 자주 함께 사용 -> 즉시 로딩
- Member와 Order는 가끔 사용 -> 지연 로딩
- Order와 Product는 자주 함께 사용 -> 즉시 로딩
- ![image](https://user-images.githubusercontent.com/102513932/200586568-f0102b0c-c1bf-4b5a-9400-de612a405a8d.png)
- ![image](https://user-images.githubusercontent.com/102513932/200586681-e13feb82-dddd-45ae-8101-e62755422801.png)
- ![image](https://user-images.githubusercontent.com/102513932/200586774-9b8637d8-474a-4232-b1f4-a899630d01ba.png)
### 지연 로딩 활용 - 실무
- **모든 연관관계에 지연 로딩을 사용하라**
- **실무에서 즉시 로딩을 사용하지 마라**
- JPQL fetch 조인이나, 엔티티 그래프 기능을 사용하라!
- 즉시 로딩은 상상하지 못한 쿼리가 나감
## 영속성 전이(CASCADE)와 고아 객체
## 실전 예제 5 - 연관관계 관리
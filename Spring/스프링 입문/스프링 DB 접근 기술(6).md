### 목차
- [H2 데이터베이스 설치](#h2-데이터베이스-설치)
  - [테이블 생성하기](#테이블-생성하기)
- [순수 JDBC](#순수-jdbc)
  - [스프링 부트 데이터베이스 연결 설정 추가](#스프링-부트-데이터베이스-연결-설정-추가)
  - [Jdbc 리포지토리 구현](#jdbc-리포지토리-구현)
  - [스프링 설정 변경](#스프링-설정-변경)
- [스프링 통합 테스트](#스프링-통합-테스트)
  - [회원 서비스 스프링 통합 테스트](#회원-서비스-스프링-통합-테스트)
- [스프링 JdbcTemplate](#스프링-jdbctemplate)
  - [스프링 JdbcTemplate 회원 리포지토리](#스프링-jdbctemplate-회원-리포지토리)
  - [JdbcTemplate을 사용하도록 스프링 설정 변경](#jdbctemplate을-사용하도록-스프링-설정-변경)
- [JPA](#jpa)
  - [build.gradle에 JPA, h2 데이터베이스 관련 라이브러리 추가](#buildgradle에-jpa-h2-데이터베이스-관련-라이브러리-추가)
  - [스프링 부트에 JPA 설정 추가](#스프링-부트에-jpa-설정-추가)
  - [JPA 엔티티 매핑](#jpa-엔티티-매핑)
  - [JPA 회원 리포지토리](#jpa-회원-리포지토리)
  - [서비스 계층에 트랜잭션 추가](#서비스-계층에-트랜잭션-추가)
  - [JPA를 사용하도록 스프링 설정 변경](#jpa를-사용하도록-스프링-설정-변경)
- [스프링 데이터 JPA](#스프링-데이터-jpa)
  - [스프링 데이터 JPA 회원 리포지토리](#스프링-데이터-jpa-회원-리포지토리)
  - [스프링 데이터 JPA 회원 리포지토리를 사용하도록 스프링 설정 변경](#스프링-데이터-jpa-회원-리포지토리를-사용하도록-스프링-설정-변경)
  - [스프링 데이터 JPA 제공 클래스](#스프링-데이터-jpa-제공-클래스)
  - [스프링 데이터 JPA 제공 기능](#스프링-데이터-jpa-제공-기능)
## H2 데이터베이스 설치
- 개발이나 테스트 용도로 가볍고 편리한 DB, 웹 화면 제공
  - 1.4.200 버전 설치
  - C:\Program Files (x86)\H2\bin
    - h2.bat 실행
  - ![image](https://user-images.githubusercontent.com/102513932/196199925-b6664917-2fae-4d9a-a137-04119f84cfe0.png)
    - 오류 발생 시
    - 1. H2 데이터베이스 종료 후 다시 시작
    - 2. 웹 브라우저 `ip 주소` -> `localhost`로 변경
    - 데이터베이스 파일 생성 시 `C:\Users\LG`에 `test.mv.db` 생성
### 테이블 생성하기
- 테이블 관리를 위해 프로젝트 루트에 `sql/ddl.sql` 파일 생성
```sql
drop table if exists member CASCADE;
create table member
(
id bigint generated by default as identity,
name varchar(255),
primary key (id)
);
```
## 순수 JDBC 
- 옛날 방식을 차용함, 편하게 정리
- build.gradle 파일에 jdbc, h2 데이터베이스 관련 라이브러리 추가
```java
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'
```
### 스프링 부트 데이터베이스 연결 설정 추가
- resuorces/application.properties
```java
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name = org.h2.driver
spring.datasource.username=sa
```
- 스프링부트 2.4부터는 `spring.datasource.username=sa`을 꼭 추가해주어야 함
  - 아니면 Wrong user name or password 오류 발생
  - 마지막에 공백이 들어가는지도 확인할 것
### Jdbc 리포지토리 구현
- JDBC API로 직접 코딩하는 것은 20년전 이야기, 참고만 하고 넘어가자
- `hello-Spring/src/main/java/hello/helloSpring/repository/JdbcMebmerRepository` 참고
### 스프링 설정 변경
```java
public class SpringConfig {

    private final DataSource dataSource;
    @Autowired
    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean // 스프링 빈을 만들겠단 의미
    public MemberService memberService(){
        return new MemberService(memberRepository());
    }
    @Bean
    public MemberRepository memberRepository(){

//        return new MemoryMemberRepository();
        return new JdbcMemberRepository(dataSource);
    }
    // 다른 어떤 코드도 건들지 않고, Jdbc멤버 리포지토리를 만들고
    // 인터페이스를 확장 후 configuration만 수정했을 뿐임
    // localHost:8080 들어가면 회원 목록에 DB에 저장했던 목록을 확인할 수 있음(DB와 연결)
}
```
- DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체임
  - 스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 DataSource를 생성하고 스프린 빈으로 만듬
  - 그래서 DI를 받을 수 있다
- ![image](https://user-images.githubusercontent.com/102513932/196241419-dcf6566e-fb23-461b-8cae-c056d7e7d5c4.png)
  - MemberService는 MemberRepository를 의존
  - 인터페이스 구현체로 MemoryMemberRepository와 JdbcMemberRepository 존재
- ![image](https://user-images.githubusercontent.com/102513932/196241490-0ab09b71-825d-42dc-9ef8-96b63baab9ff.png)
  - 개방_폐쇄 원칙(OCP, Open_Closed Principle)
    - 확장에는 열려있고, 수정, 변경에는 닫혀있음
  - 스프링의 DI(Dependencies Inject)을 사용하면 **기존 코드를 전혀 손대지 않고, 설정많으로 구현 클래스를 변경**할 수 있음
  - 회원을 등록하고 DB에 결과가 잘 입력되는지 확인
    - 데이터를 DB에 저장, 스프링 서버를 다시 실행해도 데이터 안전하게 저장 가능
## 스프링 통합 테스트
- 스프링 컨테이너와 DB까지 연결한 통합 테스트 진행
### 회원 서비스 스프링 통합 테스트
```java
@SpringBootTest
    // 스프링 컨테이너와 테스트를 함께 실행한다
@Transactional
    // Transactional은 test를 반복하기 위해서 붙는 annotation
    // 이게 없으면 afterEach를 사용해야 한다
    // 테스트를 실행할 때 transaction을 먼저 실행하고, 테스트가 끝나면 다 롤백을 해준다
    // test가 db에 영향을 주지 않게 됨
class MemberServiceIntegrationTest {
    // 여태까지 실행한 테스트는 스프링과 무관한 테스트였음
    // 지금은 db도 스프링과 연결되어 관리되고 있기 때문에, 스프링과 연관하여 test를 만들어 보겠음
    // MemberServiceTest와 차이점을 잘 살펴보자
    @Autowired MemberService memberService;
    @Autowired MemberRepository memberRepository;

    @Test
    void 회원가입() {
        //given
        Member member = new Member();
        member.setName("hello");

        //when
        Long saveId = memberService.join(member);

        //then
        Member findMember = memberService.findOne(saveId).get();
        assertThat(member.getName()).isEqualTo(findMember.getName());
    }
    @Test
    public void 중복_회원_예외(){
        //given
        Member member1 = new Member();
        member1.setName("spring");

        Member member2 = new Member();
        member2.setName("spring");
        //when
        memberService.join(member1);
        IllegalAccessError e = assertThrows(IllegalAccessError.class, () -> memberService.join(member2));
        assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");

    }
}
```
- `@SpringBootTest`
  - 스프링 컨테이너와 테스트를 함께 실행한다
- `@Transactional`
  - 테스트 케이스에 존재 시, 테스트 시작 전에 트랜잭션을 시작
  - 테스트 완료 후에 항상 롤백
  - DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않는다
- Spring을 사용하지 않은 단위 테스트는 불필요한 것인가?
  - 그렇지 않음. 실행 시간에 차이도 있을 뿐더러 테스트의 구조 상 유리한 측면이 많다
  - 상세히 기술하진 않았음
## 스프링 JdbcTemplate
- 순수 Jdbc와 동일한 환결설정
- 스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해줌
  - 하지만, SQL은 직접 작성해야 함
### 스프링 JdbcTemplate 회원 리포지토리
- src/main/java/repository/JdbcTemplateMemberRepository 참고

### JdbcTemplate을 사용하도록 스프링 설정 변경
```java
public MemberRepository memberRepository(){

//        return new MemoryMemberRepository();
//        return new JdbcMemberRepository(dataSource);
        return new JdbcTemplateMemberRepository(dataSource);
    }
```
## JPA
- JPA는 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해줌
  - JDBC Template는 반복 코드는 제거해 줬으나, SQL은 직접 작성했어야 했다
- JPA 사용 시, SQL과 데이터 중심 설계에서 객체 중심 설계로 패러다임 전환 가능
- JPA를 사용하면 개발 생산성을 크게 높일 수 있다
### build.gradle에 JPA, h2 데이터베이스 관련 라이브러리 추가
```java
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
//	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	runtimeOnly 'com.h2database:h2'
	testImplementation('org.springframework.boot:spring-boot-starter-test'){
		exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
	}
}
```
- ```spring-boot-starter-data-jap```는 내부에 jdbc 관련 라이브러리를 포함함 따라서 jdbc는 제거해도 상관 없음

### 스프링 부트에 JPA 설정 추가
`resorces/application.properties` 파일
```java
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name = org.h2.driver
spring.datasource.username=sa

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```
- ```show-sql``` : JPA가 생성하는 SQL 출력
- ```ddl-auto``` : JPA는 테이블을 자동으로 생성하는 기능을 제공
  - ```none``` 사용 시 해당 기능 off
  - ```create``` 사용 시 엔티티 정보를 바탕으로 테이블도 직접 생성해줌

### JPA 엔티티 매핑
```JAVA
@Entity
//이제 jpa가 관리하는 entity가 됨
public class Member {

    @Id // PK 매핑
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    // DB에 값을 넣으면 DB가 ID값을 자동으로 생성해주는 것을 IDENTITY 전략이라 칭함

    private Long id;
    private String name;

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }
}
```
### JPA 회원 리포지토리
```JAVA
public class JpaMemberRepository implements MemberRepository{

    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }
    //jpa는 entitymanger로 모든 것이 동작함
    //스프링부트가 각종 정보와 데이터베이스 커넥션 정보를 통합해 entitymanger를 만드는데,
    //이를 통해 db와 내부적으로 통신 처리 가능함
    //즉, jpa를 쓰려면 entitymanger를 주입받아야함
    @Override
    public Member save(Member member){
        em.persist(member);
        return member;
        //jpa가 insert query 만들어서 db에 집어넣고, id까지 만들어 줌
    }

    @Override
    public Optional<Member> findById(Long id){
        Member member = em.find(Member.class,id); // 조회 (식별자, pk값)
        return Optional.ofNullable(member);
    }

    @Override
    public Optional<Member> findByName(String name){
        List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
        // pk 기반이 아니면 jpql을 작성해야함!
        // 보통 테이블 대상으로 query를 날리는데,
        // jpql(객체지향 쿼리)은 객체(entity)를 대상으로 함
        // 불필요한 매핑 과정 생략 가능
    }
}
```
### 서비스 계층에 트랜잭션 추가
```JAVA
@Transactional //jpa 사용시 항상 transaction이 있어야 함
public class MemberService {}
```
- ```org.springframework.transaction.annotation.Transactional``` 사용
- 스프링은 해당 클래스의 메서드를 실행할 때 트랜잭션을 시작
  - 메서드가 정상 종료되면 트랜잭션 커밋
  - 만일 런타임 예외 발생 시 롤백
- **JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 한다**

### JPA를 사용하도록 스프링 설정 변경
```JAVA
@Configuration
public class SpringConfig {

    private DataSource dataSource;
    private final EntityManager em;
    @Autowired
    public SpringConfig(DataSource dataSource, EntityManager em) {
        this.dataSource = dataSource;
        this.em = em;
    }

    @Bean // 스프링 빈을 만들겠단 의미
    public MemberService memberService(){
        return new MemberService(memberRepository());
    }
    @Bean
    public MemberRepository memberRepository(){

//        return new MemoryMemberRepository();
//        return new JdbcMemberRepository(dataSource);
//        return new JdbcTemplateMemberRepository(dataSource);
        return new JpaMemberRepository(em);
    }
}
```
## 스프링 데이터 JPA
- 스프링 부트와 JPA만 사용해도 개발 생산성이 많이 증가하고, 코드도 확연히 줄어듬
- 만일 여기에 스프링 데이터 JPA를 사용하면, 기존의 한계를 넘어 리포지토리에 구현 클래스 없이 인터페이스 만으로 개발 가능
  - 반복 개발해온 기본 CRUD 기능도 스프링 데이터 JPA가 모두 제공
- 스프링 부트와 JPA라는 기반 위에, 스프링 데이터 JAP라는 프레임워크를 더하면, 개발자는 핵심 비즈니스 로직을 개발하는데 더욱 집중할 수 있음
- 단, 스프링 데이터 JAP는 JPA를 편리하게 사용하도록 도와주는 기술임
  - 따라서 JPA를 선행 학습한 후 스프링 데이터 JPA를 학습할 것

### 스프링 데이터 JPA 회원 리포지토리
```JAVA
public interface SpringDataJpaMemberRepository extends JpaRepository<Member, Long>, MemberRepository {

    // interface만 만들어 놓고,
    // extends만 해놓으면 Spring data jpa가 interface에 대한 구현체를 만들고 spring 빈에 등록함
    // 그리고 DI를 통해 injection을 받음
    @Override
    Optional<Member> findByName(String name);
}
```
### 스프링 데이터 JPA 회원 리포지토리를 사용하도록 스프링 설정 변경
```JAVA
public class SpringConfig {

    private  final MemberRepository memberRepository;

    @Autowired
    public SpringConfig(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Bean 
    public MemberService memberService(){
        return new MemberService(memberRepository);
    }
}
```
- 스프링 데이터 JPA가 `SpringDataJpaMemberRepository`를 스프링 빈으로 자동 등록해준다
  - 프록시라는 기술을 통해 객체를 생성 후 스프링 빈에 등록

### 스프링 데이터 JPA 제공 클래스
![image](https://user-images.githubusercontent.com/102513932/196451783-69b20cff-c813-44ca-8c25-15081bca8de3.png)
- 통용되는 메서드는 구현되어 있음
  - 다만, business마다 다른 메서드(ex : 주문서 번호로 조회, 고객이 주문한 상품 이름으로 조회)는 따로 구현해 줘야함
    - 이 구현마저도, 간단한 구현은 인터페이스로 처리 가능
    - 위 코드에서 `findByName`을 override할 시
      - JPQL : `select m from Member m where m.name =?`로 처리해버림

### 스프링 데이터 JPA 제공 기능
- 인터페이스를 통한 기본적인 CRUD
- `findByName()`, `findByEmail()` 처럼 메서드 이름만으로 조회 기능 제공
- 페이징 기능 자동 제공
- 위 코드 같은 경우, `org.springframework.data.jpa.repository.JpaRepository`에 구현되어 있음

> 참고: 실무에서는 jpa와 스프링 데이터 jpa를 기본으로 사용, 복잡한 동적 쿼리는 Querydsl이라는 라이브러리를 사용하면 된다. Querydsl을 사용하면 쿼리도 자바 코드로 안전하게 작성할 수 있고, 동적 쿼리도 편리하게 작성할 수 있다. 이 조합으로 해결하기 어려운 쿼리는 JPA가 제공하는 네이티브 쿼리를 사용하거나, 앞서 학습한 스프링 JdbcTemplate를 사용하면 된다.
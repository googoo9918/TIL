## 빈 스코프란?
- 스코프는 번역 그대로 빈이 존재할 수 있는 범위를 뜻함
- 스프링이 지원하는 스코프
  - 싱글톤
    - 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
  - 프로토타입
    - 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여
    - 더는 관리하지 않는 매우 짧은 범위의 스코프
  - 웹 관련 스코프
    - request
      - 웹 요청이 들어오고 나갈 때 까지 유지되는 스코프
    - session
      - 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
    - application
      - 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프
### 빈 스코프 등록 방법
- 컴포넌트 스캔 자동 등록
```java
@Scope("prototype")
@Component
public class HelloBean{}
```
- 수동 등록
```java
@Scope("prototype")
@Bean
PrototypeBean HelloBean(){
    return new HelloBean();
}
```
## 프로토타입 스코프
- 싱글톤 스코프의 빈 조회 시 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈 반환
- 반면, 프로토타입 스코프를 스프링 컨테이너 조회 시 스프링 컨테이너는 항상 새로운 인스턴스를 생성해 반환
### 싱글톤 빈 요청
![image](https://user-images.githubusercontent.com/102513932/197919716-17aee678-369e-4329-99fc-fede16465e3a.png)
- 1. 싱글톤 스코프의 빈을 스프링 컨테이너에 요청
- 2. 스프링 컨테이너는 본인이 관리하는 스프링 빈을 반환
- 3. 이후 스프링 컨테이너에 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈 반환
### 프로토타입 빈 요청1
![image](https://user-images.githubusercontent.com/102513932/197919750-504ee83c-9955-4687-b0b5-ceb17c648d70.png)
- 1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청
- 2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성, 필요한 의존관계 주입
![image](https://user-images.githubusercontent.com/102513932/197919941-9ce038e4-53a1-475d-87e1-37d7e90ad0fb.png)
- 3. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환
- 4. 이후 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해 반환

### 정리
- 스프링 컨테이너는 프로토타입 빈을 **생성하고, 의존관계 주입, 초기화**까지만 처리함
  - 이후에는 생성된 프로토타입 빈을 관리하지 않음
- 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있음
  - `@PreDestroy`같은 종료 메서드가 호출되지 않음

### 싱글톤 스코프 빈 테스트
```java
public class SingletonTest {

    @Test
    public void singletonBeanFind() {
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SingletonBean.class);
        SingletonBean singletonBean1 = ac.getBean(SingletonBean.class);
        SingletonBean singletonBean2 = ac.getBean(SingletonBean.class);
        System.out.println("singletonBean1 = " + singletonBean1);
        System.out.println("singletonBean2 = " + singletonBean2);
        Assertions.assertThat(singletonBean1).isEqualTo(singletonBean2);

        ac.close(); // 종료
    }

    @Scope("singleton")
    static class SingletonBean{
        @PostConstruct
        public void init(){
            System.out.println("SingletonBean.init");
        }

        @PreDestroy
        public void destroy(){
            System.out.println("SingletonBean.destroy");
        }
    }
}
```
- 출력 결과
```
SingletonBean.init
singletonBean1 = hello.core.scope.SingletonTest$SingletonBean@265adfad
singletonBean2 = hello.core.scope.SingletonTest$SingletonBean@265adfad
11:39:48.862 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@290222c1, started on Wed Oct 26 11:39:48 KST 2022
SingletonBean.destroy
```
- 빈 초기화 메서드 실행
- 같은 인스턴스의 빈 조회
- 종료 메서드까지 정상 호출

### 프로토타입 스코프 빈 테스트
```java
public class PrototypeTest {
    @Test
    public void prototypeBeanFind() {
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class);
        System.out.println("find prototypeBean1");
        PrototypeBean prototypeBean1 = ac.getBean(PrototypeBean.class);
        System.out.println("find prototypeBean2");
        PrototypeBean prototypeBean2 = ac.getBean(PrototypeBean.class);
        System.out.println("prototypeBean1 = " + prototypeBean1);
        System.out.println("prototypeBean2 = " + prototypeBean2);
        Assertions.assertThat(prototypeBean1).isNotSameAs(prototypeBean2);
        ac.close();
    }

    @Scope("prototype")
    static class PrototypeBean{
        @PostConstruct
        public void init(){
            System.out.println("PrototypeBean.init");
        }

        @PreDestroy
        public void destroy(){
            System.out.println("PrototypeBean.destroy");
        }
    }
}
```
### 실행 결과
```
find prototypeBean1
PrototypeBean.init
find prototypeBean2
PrototypeBean.init
prototypeBean1 = hello.core.scope.PrototypeTest$PrototypeBean@265adfad
prototypeBean2 = hello.core.scope.PrototypeTest$PrototypeBean@a3d9978
11:47:28.380 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@290222c1, started on Wed Oct 26 11:47:27 KST 2022
```
- 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드 실행
  - 반면 프로토타입 스코프의 빈은 스프링 컨테이너에서 빈을 조회할 때 생성, 초기화 메서드 실행
- 프로토타입 빈을 2번 조회
  - 완전히 다른 빈 생성, 초기화도 두 번 실행
- 싱글톤 빈은 스프링 컨테이너가 관리하기 때문에 스프링 컨테이너가 종료될 때 빈의 종료 메서드 실행
  - 반면 프로토타입 빈은 스프링 컨테이너가 생성과 의존관계 주입, 초기화까지만 관여하고 더는 관리하지 않음
    - 스프링 컨테이너 종료 시 `@PreDestroy`같은 종료 메서드 실행되지 않음

### 프로토타입 빈 특징 정리
- 스프링 컨테이너에 요청할 때 마다 새로 생성
- 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입, 초기화까지만 관여
- 종료 메서드 호출되지 않음
- 프로토타입 빈을 조회한 클라이언트가 관리해야함
  - 종료 메서드에 대한 호출 또한 클라이언트가 직접 해야함
## 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 문제점
- 스프링 컨테이너에 프로토타입 스코프의 빈을 요청하면 항상 새로운 객체 인스턴스를 생성해 반환함
  - 하지만 싱글톤 빈과 함께 사용할 때는 의도한 대로 잘 동작하지 않으므로 주의
### 프로토타입 빈 직접 요청
- 스프링 컨테이너에 프로토타입 빈 직접 요청1
  - ![image](https://user-images.githubusercontent.com/102513932/197933892-d61fb73a-a28f-4dbd-97ef-da9506c5b01f.png)
  - 1. 클라이언트A는 스프링 컨테이너에 프로토타입 빈을 요청
  - 2. 스프링 컨테이너는 프로토타입 빈을 새로 생성해 반환(x01)함
    - 해당 빈의 count 필드 값은 0
  - 3. 클라이언트는 조회한 프로토타입 빈에 `addCount()`를 호출, count필드를 +1
  - 결과적으로 프로토타입 빈(x01)의 count는 1이 됨
- 스프링 컨테이너에 프로토타입 빈 직접 요청2
  - ![image](https://user-images.githubusercontent.com/102513932/197934198-346a508b-f0eb-4409-a9a2-6327aaa5dcf9.png)
  - 1. 클라이언트B는 스프링 컨테이너에 프로토타입 빈 요청
  - 2. 스프링 컨테이너는 프로토타입 빈을 새로 생성해 반환(x02)함
    - 해당 빈의 count필드 값은 0임
  - 3. 클라이언트는 조회한 프토토타입 빈에 `addCount()`를 호출, count필드 +1
  - 결과적으로 프로토타입 빈(x02)의 count는 1이 됨
- 코드
```java
public class SingletonWithPrototypeTest1 {

    @Test
    void prototypeFind() {
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class);
        PrototypeBean prototypeBean1 = ac.getBean(PrototypeBean.class);
        prototypeBean1.addCount();
        assertThat(prototypeBean1.getCount()).isEqualTo(1);
        PrototypeBean prototypeBean2 = ac.getBean(PrototypeBean.class);
        prototypeBean2.addCount();
        assertThat(prototypeBean2.getCount()).isEqualTo(1);
    }

    @Scope("prototype")
    static class PrototypeBean{
        private int count =0;

        public void addCount(){
            count++;
        }

        public int getCount() {
            return count;
        }

        @PostConstruct
        public void init(){
            System.out.println("PrototypeBean.init");
        }
        @PreDestroy
        public void destroy(){
            System.out.println("PrototypeBean.destroy");
        }
    }
}
```
- 실행 결과
```
PrototypeBean.init
PrototypeBean.init
```
### 싱글톤 빈에서 프로토타입 빈 사용
- `clientBean`이라는 싱글톤 빈이 의존관계 주입을 통해 프로토타입 빈을 주입 받아서 사용하는 예제
- 싱글톤에서 프로토타입 빈 사용1
- ![image](https://user-images.githubusercontent.com/102513932/197935586-ea117fcb-2b3c-4e0b-9573-df126f5c5961.png)
  - `clientBean`은 싱글톤이므로, 스프링 컨테이너 생성 시점에 함께 생성되고 의존관계 주입도 발생함
  - 1. `clientBean`은 의존관계 자동 주입 사용, 주입 시점에 스프링 컨테이너에 프로토타입 빈 요청
  - 2. 스프링 컨테이너는 프로토타입 빈을 생성해 `clientBean`에 반환, 프로토타입 빈의 count 필드 값은 0
  - 이제 `clientBean`은 프로토타입 빈을 내부 필드에 보관(참조값 보관)
- 싱글톤에서 프로토타입 빈 사용2
- ![image](https://user-images.githubusercontent.com/102513932/197935816-5e640655-1161-45dd-86b8-c682bc8b09bd.png)
  - 클라이언트A는 `clientBean`을 스프링 컨테이너에 요청해 받음
    - 싱글톤이므로 항상 같은 `clientBean`이 반환됨
  - 3. 클라이언트 A는 `clientBean.logic()`을 호출
  - 4. `clientBean`은 prototypeBean의 `addCount()`를 호출해 프로토타입 빈의 count를 증가, count값이 1이 됨
- 싱글톤에서 프로토타입 빈 사용3
- ![image](https://user-images.githubusercontent.com/102513932/197936363-31e63281-c6a4-4aa1-854f-674d04119422.png)
  - 클라이언트 B는 `clientBean`을 스프링 컨테이너에 요청해서 받음
    -  싱글톤이므로 항상 같은 `clientBean`이 반환됨
  - 이때, clientBean이 내부에 갖고 있는 프로토타입 빈은 이미 **과거에 주입이 끝난 빈**
    - 주입 시점에 스프링 컨테이너에 요청해 프로토타입 빈이 새로 생성된 것이지, 사용 할때마다 새로 생성되는 것이 아님
  - 5. 클라이언트B는 `clientBean.logic()` 호출
  - 6. `clientBean`은 prototypeBean의 `addCount()`를 호출해 프로토타입 빈의 count를 증가, **count값이 2가 됨(문제 발생)**
- 예제 코드
```java
public class SingletonWithPrototypeTest1 {

    @Test
    void prototypeFind() {
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(ClientBean.class, PrototypeBean.class);
        ClientBean clientBean1 = ac.getBean(ClientBean.class);
        int count1 = clientBean1.logic();
        assertThat(count1).isEqualTo(1);
        ClientBean clientBean2 = ac.getBean(ClientBean.class);
        int count2 = clientBean2.logic();
        assertThat(count2).isEqualTo(2);
    }

    @Scope("singleton")
    static class ClientBean{
        private final PrototypeBean prototypeBean;

        @Autowired
        public ClientBean(PrototypeBean prototypeBean) {
            this.prototypeBean = prototypeBean;
        }

        public int logic(){
            prototypeBean.addCount();
            int count = prototypeBean.getCount();
            return count;
        }
    }
    @Scope("prototype")
    static class PrototypeBean {
        private int count = 0;

        public void addCount() {
            count++;
        }

        public int getCount() {
            return count;
        }

        @PostConstruct
        public void init() {
            System.out.println("PrototypeBean.init");
        }

        @PreDestroy
        public void destroy() {
            System.out.println("PrototypeBean.destroy");
        }
    }
}
```
- 출력 결과
```
PrototypeBean.init
```
- 스프링은 일반적으로 싱글톤 빈을 사용하므로, 싱글톤 빈이 프로토타입 빈을 사용하게 됨
  - 그런데 싱글톤 빈은 생성 시점에만 의존관계 주입을 받음
    - 따라서 프로토타입 빈이 새로 생성되긴 하지만, 싱글톤 빈과 함께 **계속 유지**됨
  - 문제
    - 프로토타입 빈을 사용할 때 마다 새로 생성해서 사용하려면 어떻게 해야 하는가? 

> 참고: 여러 빈에서 같은 프로토타입 빈을 주입 받으면, 주입 받는 시점에 각각 새로운 프로토 타입 빈이 생성됨. <br>
> ex) clientA -> prototypeBean@x01 <br>
> ex) clientB -> prototypeBean@x02 <br>
> 물론 사용할 때 마다 새로 생성되는 것은 아님
## 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결
## 웹 스코프
## request 스코프 예제 만들기
## 스코프와 Provider
## 스코프와 프록시
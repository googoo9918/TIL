### 목차
- [스프링이란?](#스프링이란)
  - [스프링 프레임워크](#스프링-프레임워크)
  - [스프링 부트](#스프링-부트)
  - [스프링의 핵심 개념 컨셉](#스프링의-핵심-개념-컨셉)
- [좋은 객체 지향 프로그래밍이란?](#좋은-객체-지향-프로그래밍이란)
  - [다형성](#다형성)
    - [역할과 구현을 분리](#역할과-구현을-분리)
    - [객체의 협력](#객체의-협력)
  - [자바 언어의 다형성](#자바-언어의-다형성)
  - [스프링과 객체 지향](#스프링과-객체-지향)
- [좋은 객체 지향 설계의 5가지 원칙](#좋은-객체-지향-설계의-5가지-원칙)
  - [SRP: 단일 책임 원칙](#srp-단일-책임-원칙)
  - [OCP: 개방-폐쇄 원칙](#ocp-개방-폐쇄-원칙)
    - [문제점](#문제점)
  - [LSP: 리스코프 치환 원칙](#lsp-리스코프-치환-원칙)
  - [ISP: 인터페이스 분리 원칙](#isp-인터페이스-분리-원칙)
  - [DIP: 의존관계 역전 원칙](#dip-의존관계-역전-원칙)
    - [문제점](#문제점-1)
  - [정리](#정리)
- [객체 지향 설계와 스프링](#객체-지향-설계와-스프링)
- [정리](#정리-1)
## 스프링이란?
- 필수
### 스프링 프레임워크
- 핵심 기술
  - 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술
  - 스프링 MVC, 스프링, WebFlux
- 데이터 접근 기술
  - 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합
  - 캐시, 이메일, 원격접근, 스케줄링
- 테스트
  - 스프링 기반 테스트 지원
- 언어
  - 코틀린, 그루비
- 스프링 부트를 통해 스프링 프레임워크의 기술들을 편리하게 사용
### 스프링 부트
- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션 쉽게 생성
- Tomcat 같은 웹 서버 내장, 별도 웹 서버 설치X
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
  - 라이브러리가 연결되어 알아서 추가됨
- 스프링과 3rd parth(외부) 라이브러리 자동 구성
  - 버전별로 맞추기 힘들었던 외부 라이브러리 버전 조합을 자동으로 맞춰줌
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
  - 운영환경에서 모니터링 같은 기능을 기본적으로 제공
- 관례에 의한 간결한 설정
  - 매뉴얼이 잘 나와있고, 필요할 때만 구체화 하면 됨
- 스프링 단어
  - 스프링이라는 단어 문맥에 따라 다른 의미를 가짐
    - 스프링 DI 컨테이너 기술
    - 스프링 프레임워크
    - 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생테계
- 선택
  - 스프링 데이터
    - 관계형 데이터베이스 사용 편리하도록
  - 스프링 세션
    - 세션 기능 사용 편리하도록
  - 스프링 시큐리티
    - 보안 관련
  - 스프링 Rest Docs
    - API 문서화 용이
  - 스프링 배치
    - 데이터 일부분 처리 특화
  - 스프링 클라우드
    - 클라우드 기술 특화
  - Spring.io/projects/Overview 에서 확인해 볼 것
### 스프링의 핵심 개념 컨셉
- 스프링은 자바 언어 기반의 프레임워크
  - 자바의 가장 큰 특징 -> 객체 지향
  - 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
  - 스프링은 **좋은 객체 지향** 애플리케이션을 개발할 수 있게 돕는 프레임워크

## 좋은 객체 지향 프로그래밍이란?
- 객체 지향 프로그래밍
  - 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 *객체*들의 *모임*으로 파악하고자 함
  - 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음 (협력)
  - 프로그램을 유연하고 변경이 용이하게 만듬, 대규모 소프트웨어 개발에 많이 사용
    - 컴포넌트를 쉽고 유연하게 변경
### 다형성
- 다형성의 실세계 비유
  - 역할(인터페이스)과 구현(객체)으로 세상을 구분
- ![image](https://user-images.githubusercontent.com/102513932/196604822-47577f58-6bfb-4c6a-b068-c06cbaac4780.png)
  - 운전자는 자동차 역할(인터페이스)과만 연관 관계를 가짐
    - 자동차가 바뀌어도(다른 구현이 적용돼도) 운전자에게 영향을 끼치지 않음
    - 변경이 용이(독립적)
    - 클라이언트(운전자)에게 영향을 주지 않고 새로운 기능을 제공할 수 있음
      - 무한히 확장 가능
#### 역할과 구현을 분리
- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경이 편리해짐
- 장점
  - 클라이언트는 대상의 역할(인터페이스)만 알면 됨
  - 클라이언트는 구현 대상의 내부 구조를 몰라도 됨
  - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않음
  - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않음
- 자바 언어의 다형성 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체
  - 객체 설계 시 역할과 구현의 명확한 분리
  - 객체 설계 시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기
    - 인터페이스를 안정적으로 잘 설계하는 것이 중요!
#### 객체의 협력
- 혼자 있는 객체는 없음
- 클라이언트 : 요청, 서버: 응답
- 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가짐
- ![image](https://user-images.githubusercontent.com/102513932/196606131-eb0b668b-c0dd-478c-8183-09617ebbc52a.png)

### 자바 언어의 다형성
- ![image](https://user-images.githubusercontent.com/102513932/196608192-f04f4488-afff-437b-947c-b61439801b2d.png)
- ![image](https://user-images.githubusercontent.com/102513932/196608172-a0d93e22-2bc1-4192-8789-f68819097e6d.png)
  - 자바는 다형성을 오버라이딩을 통해 표현
  - 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능
    - 이는 상속관계에서도 동일하게 적용
  - 클라이언트는 현재 MemberRepository를 의존하고 있음
    - MemberRepository에 두 가지 클래스가 들어갈 수 있음  
```java
//ex1)
private MemberRepository memberRepository = new MemoryMemberRepository();
//ex2)
private MemberRepository memberRepository = new JdbcMemberRepository();
```
- 다형성의 본질
  - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경 가능
  - 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작
  - **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다**
- 한계
  - 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생함
    - 인터페이스를 안정적으로 잘 설계하는 것이 중요!

### 스프링과 객체 지향
- 다형성이 가장 중요함
  - 스프링은 다형성을 극대화해서 이용할 수 있게 도와줌
  - IoC, DI는 다형성을 활용해 역할과 구현을 편리하게 다룰 수 있도록 지원한다
  - 스프링을 사용 시 구현을 편리하게 변경할 수 있다

## 좋은 객체 지향 설계의 5가지 원칙
### SRP: 단일 책임 원칙
- Single responsibility principle
- 한 클래스는 하나의 책임만 가져야 한다
  - 하나의 책임의 기준은 모호함
    - 문맥과 상황에 따라 다름
- 중요한 기준은 **변경**
  - 변경이 있을 때 파급 효과가 적은 것이 중요
    - 범위가 너무 넓어도, 너무 좁아도 안됨
- ex) UI 변경, 객체의 생성과 사용을 분리
### OCP: 개방-폐쇄 원칙
- Open/closed principle
- 확장에는 열려 있으나 변경에는 닫혀 있어야 함
  - 다형성 활용
- 인터페이스를 구현한 새로운 클래스를 통해 새로운 기능 구현
#### 문제점
  - MemberServic 클라이언트가 구현 클래스를 직접 선택(위 MemberService 코드 참고)
  - 구현 객체를 변경하려면 클라이언트 코드를 변경해야 함
    - 다형성을 사용했지만 OCP 원칙을 지키지 못함
      - 해결: 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자 필요
### LSP: 리스코프 치환 원칙
- Liskov substitution principle
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 함
  - 이는 다형성을 지원하기 위한 원칙임
    - 인터페이스를 구현한 구현체를 믿고 사용하려면 원칙이 필요함
    - 단순히 컴파일의 성공이 아닌, 규악과 정확성을 위해 필요
- ex) 자동차 인터페이스의 엑셀은 앞으로 가는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함
### ISP: 인터페이스 분리 원칙
- Interface segregation principle
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 나음
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리 시 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확해지고, 대체 가능성이 높아짐
### DIP: 의존관계 역전 원칙
- Dependency inversion principle
- 프로그래머는 **추상화에 의존해야지, 구체화에 의존하면 안됨**
  - 의존성 주입은 이 원칙을 따르는 방법 중 하나
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라
  - 클라이언트 코드(MemberService)가 인터페이스(MemberRepository)만 바라보고, 구현체에 대해서는 몰라야 함
- **역할**에 의존하게 해야 한다
  - 클라이언트가 인터페이스에 의존해야 유연하게 구현체 변경 가능
  - 구현체 의존 시 변경이 매우 어려워짐
#### 문제점
  - OCP에서 나온 MemberService는 인터페이스에 의존함과 동시에 구현 클래스에도 의존
    - 의존은 그냥 연관관계가 있다는 소리
  - MemberService 클라이언트가 구현 클래스를 직접 선택
  - ```MemberRepository m = new MemoryMemberRepository();```
    - **DIP 위반**
### 정리
- 객체 지향의 핵심은 다형성
- 다만, 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없음
- 다형성만 있다면 구현 객체를 변경할 때 클라이언트 코드도 함께 변경됨
- 다형성 만으로는 **OCP, DIP**를 지킬 수 없음
- 추가적인 것이 필요

## 객체 지향 설계와 스프링
- 스프링은 DI를 통해 다형성 + OCP,DIP를 가능하게 지원
  - DI : 의존관계, 의존성 주입
  - DI 컨테이너 제공
- 클라이언트 코드의 변경 없이 기능 확장 가능
- 쉽게 부품 교체하듯 개발
- 순수하게 자바로 OCP, DIP 원칙을 지키며 개발을 하면 결국 스프링 프레임워크를 만들게 됨(정확히는 DI 컨테이너)

## 정리
- 모든 설계에 역할과 구현을 분리
- 이상적으로는 모든 설계에 인터페이스를 부여
  - 다만, 추상화에 대한 비용 발생
    - 사용하고자 할 때, 인터페이스만 보고 확인할 수 없으니 객체를 한 번 더 확인해야 함
    - 기능을 확장할 가능성이 없다면 구현 클래스를 직접 사용하는 것도 방법
      - 향후 필요하다면 리팩터링을 통한 인터페이스 도입 가능
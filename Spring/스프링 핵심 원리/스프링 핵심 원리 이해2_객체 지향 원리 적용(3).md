## 새로운 할인 정책 개발
### RateDiscountPolicy 추가
![image](https://user-images.githubusercontent.com/102513932/196876915-4edf4d86-8ca9-4d2f-8491-3fe0c2219977.png)
### RateDiscountPolicy 코드 추가
```java
//할인 정책 구현체 (비율 할인)
public class RateDiscountPolicy implements DiscountPolicy{

    private int discountPercent = 10;
    @Override
    public int discount(Member member, int price) {
        if(member.getGrade() == Grade.VIP){
            return price * discountPercent/100;
        }else{
            return 0;
        }
    }
}
```
### 테스트 작성
```java
class RateDiscountPolicyTest {

    RateDiscountPolicy rateDiscountPolicy = new RateDiscountPolicy();

    @Test
    @DisplayName("VIP 10% 할인이 적용되는가?")
    void vip_o(){
        Member member = new Member(1l,"memberA", Grade.VIP);
        int discount = rateDiscountPolicy.discount(member, 10000);

        assertThat(discount).isEqualTo(1000);
    }

    @Test
    @DisplayName("VIP가 아니면 10% 할인이 적용안되는가?")
    void vip_x(){
        Member member = new Member(1l,"memberA", Grade.BASIC);
        int discount = rateDiscountPolicy.discount(member, 10000);

        assertThat(discount).isEqualTo(0);
    }
}
```
## 새로운 할인 정책 적용과 문제점
- 추가한 할인 정책을 적용해보자
- 할인 정책을 변경하려면 `OrderSerivceImpl` 코드를 변경해야함
```java
public class OrderServiceTmple implements OrderService{
    // private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
    private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
}
```
- **문제점 발견**
  - 역할과 구현을 충분히 분리함 -> O
  - 다형성 활용, 인터페이스와 구현 객체를 분리 -> O
  - OCP, DIP와 같은 객체지향 설계 원칙 준수 
    - -> 그렇게 보이지만 사실 아님
    - DIP: 위 코드의 클래스 의존관계를 분석해보면, 추상(인터페이스)뿐 아니라 구체(구현) 클래스에도 의존하고 있음
      - 추상(인터페이스) 의존 : `DiscountPolicy`
      - 구체(구현) 클래스 : `FixDiscountPolicy`, `RateDiscountPolicy`
    - OCP: 변경하지 않고 확장해야 함
      - 지금 코드는 기능을 확장해서 변경할 때, **클라이언트 코드에 영향**을 준다
      - 따라서 OCP 위반
### 기대했던 의존관계
![image](https://user-images.githubusercontent.com/102513932/196887251-33ac7f2d-4007-4968-b87d-818b73acdcad.png)
- 여태 단순히 DiscountPolicy에만 의존한다 생각
### 실제 의존관계
![image](https://user-images.githubusercontent.com/102513932/196887316-21f4cdf0-0a49-4558-a450-9337c38d337e.png)
- DiscountPolicy 인터페이스 뿐 아니라 FixDiscountPolicy인 구체 클래스에도 함께 의존하고 있음 -> **DIP 위반!**
![image](https://user-images.githubusercontent.com/102513932/196887757-dd94b9e3-43e3-447c-9ff0-dacd99ecbd64.png)
- 위의 이유로, FixDiscountPolicy를 RateDiscountPolicy로 변경하는 순간 OrderServiceIMPL의 소스코드도 함께 변경해야 함 -> **OCP 위반**

### 문제 해결
- DIP 위반 -> 추상(인터페이스)에만 의존하도록 의존관계 변경
```java
public class OrderServiceImpl implements OrderService{
    //private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
    private DiscountPolicy discountPolicy;
}
```
- 인터페이스만 의존하도록 설계와 코드 변경
  - 근데 구현체가 없음.. 이건 아무리 봐도 아닌데?
  - NPE(null pointer exception) 발생
- 해결방안
  - 누군가가 클라이언트인 ```OrderServiceImple```에 ```DiscountPolicy```의 구현 객체를 대신 생성하고 주입해야 함
## 관심사의 분리
- 애플리케이션을 하나의 공연이라 생각해보자
  - 배역에 맞는 배우를 선택하는 것은 누가 하는가?
- 로미오와 줄리엣 공연을 하면, 로미오 역할을 누가 할지 줄리엣 역할을 누가 할지는 배우들이 정하는게 아님
  - 이전 코드는 마치 로미오 역할(인터페이스)를 하는 배우(구현체)가 줄리엣 역할(인터페이스)을 하는 배우(구현체)를 직접 초빙하는 것과 같음
    - 로미오 역할 배우는 공연도 하고, 동시에 여자 배우도 정해야 하는 **다양한 책임**을 갖고 있음
- 관심사를 분리하라
  - 배우는 본인의 역할인 배역을 수행하는 것에만 집중
  - 남자 배우는 어떤 여자 주인공이 선택되더라도 똑같이 공연할 수 있어야 함
  - 공연을 구성, 배우를 섭외, 배우를 지정하는 책임을 담당하는 별도의 **기획자**가 등장할 시점
  - 기획자를 생성하여 배우와 공연 기획자의 책임을 확실히 분리하자
### AppConfig
- 애플리케이션의 전체 동작 방식을 구성(config)하기 위함
  - 구현 객체를 생성 및 연결하는 책임을 갖는 별도의 설정 클래스
```java
public class AppConfig {

    public MemberService memberService(){
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    public OrderService orderService(){
        return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
    }
}
```
- AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성
  - `MemberServiceImpl`
  - `MemoryMemberRepository`
  - `OrderServiceImpl`
  - `FixDiscountPolicy`
- AppConfig는 생성한 객체 인스턴스의 참조(레퍼런스)를 **생성자를 통해 주입**해줌
  - `MemberServiceImpl` -> `MemoryMemberRepository`
  - `OrderServiceImpl` -> `MemoryMemberRepository`, `FixDiscountPolicy`
  - 당연히 각 구현체의 생성자 또한 만들어 줘야 함!
### MemberServiceImpl, OrderSericeImpl - 생성자 주입
```java
private final MemberRepository memberRepository;
    public MemberServiceImpl(MemberRepository memberRepository){
        this.memberRepository =memberRepository;
    }
```
```java
private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
```
- 설계 변경으로 더 이상 Impl은 `MemoryMemberRepository`를 의존하지 않음!
- 단지 `MemberRepository` 인터페이스만 의존함
- Impl 입장에서 생성자를 통해 어떤 구현 객체가 들어올지는 알 수 없음
  - 어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에서 결정됨
- Impl은 이제부터 의존관계에 대한 고민은 **외부에 맡기고 실행에만 집중**함

### 클래스 다이어그램
![image](https://user-images.githubusercontent.com/102513932/196903419-421b2482-3a8e-407d-96d0-4a25a9945e2c.png)
- 객체의 생성과 연결은 ```AppConfig```가 담당함
- **DIP 완성** : `MemberServiceImpl`은 `MemberRepository`인 추상에만 의존하면 됨
  - 이제 구현 클래스를 몰라도 된다
- **관심사 분리** : 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리

### 회원 객체 인스턴스 다이어그램
![image](https://user-images.githubusercontent.com/102513932/196904153-a57528ca-540d-4471-8435-323723bd15c4.png)
- `AppConfig` 객체는 `memoryMemberRepository` 객체를 생성, 그 참조 값을 `memberServiceImpl`을 생성하며 생성자로 전달함
- 클라이언트인 `memberServiceImpl` 입장에서 보면, 의존관계를 마치 외부에서 주입해주는 것과 같음
  - 이를 **DI**(Dependency Injection), 의존관계 주입 혹은 의존성 주입이라 칭함

### AppConfig 실행
```java
//MemberApp에서의 AppConfig 사용
//java로만 작성한 test 코드
public class MemberApp {
    public static void main(String[] args) {
        AppConfig appConfig = new AppConfig();
        MemberService memberService = appConfig.memberService();
        // MemberService memberService = new MemberSerivceImple();
        Member member = new Member(1l,"memberA", Grade.VIP);
        memberService.join(member);

        Member findMember = memberService.findMember(1l);
        System.out.println("member = " + member.getName());
        System.out.println("findMember = " + findMember.getName());
    }
}
```
- `AppConfig`의 ` return new MemberServiceImpl(new MemoryMemberRepository());`가 알아서 다 처리함
```java
//OrderApp에서의 AppConfig 사용
// main을 통한 Order test
public class OrderApp {
    public static void main(String[] args) {
        AppConfig appConfig = new AppConfig();
        MemberService memberService = appConfig.memberService();
        OrderService orderService = appConfig.orderService();

        Long memberId = 1l;
        Member member = new Member(memberId, "memberA", Grade.VIP); // 회원 객체 생성
        memberService.join(member); // 회원 가입

        Order order = orderService.createOrder(memberId, "itemA", 10000); //주문 객체 생성
        System.out.println("order = " + order); // 출력 제대로 되는가?
    }
}
```
### 테스트 코드 오류 수정
```java
public class MemberServiceTest {
    MemberService memberService;

    @BeforeEach
    public void beforeEach(){
        AppConfig appConfig = new AppConfig();
        memberService = appConfig.memberService();
    }
}
// Test마다 새로 만들어주기
```
```java
public class OrderServiceTest {

    MemberService memberService;
    OrderService orderService;
    @BeforeEach
    public void beforeEach(){
        AppConfig appConfig = new AppConfig();
        memberService = appConfig.memberService();
        orderService = appConfig.orderService();
    }
}
```
### 정리
- AppConfig를 통해 관심사를 확실히 분리함
- 역할에 따른 구현체를 변경하고 싶을 때, **AppConfig의 코드만 수정**하면 됨
  - 다른 구현체의 코드는 전혀 건들지 않아도 좋다!
  - 구현체는 담당 기능을 실행하는 책임만 지면 된다
## AppConfig 리팩터링
- 현재 AppConfig를 보면 중복이 있고, 역할에 따른 구현이 잘 보이지 않음
- 기대하는 그림
![image](https://user-images.githubusercontent.com/102513932/196913972-13b4c451-e564-43d9-9632-48ed9f286d49.png)
### 리팩터링 전
```java
public class AppConfig {

    public MemberService memberService(){
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    public OrderService orderService(){
        return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
    }
}
```
- 중복을 제거하고, 역할에 따른 구현이 보이도록 리팩터링
### 리팩터링 후
```java
public class AppConfig {

    public MemberService memberService(){
        return new MemberServiceImpl(memberRepository());
    }

    public OrderService orderService(){
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    public MemberRepository memberRepository(){
        return new MemoryMemberRepository();
    }
    
    public DiscountPolicy discountPolicy(){
        return new FixDiscountPolicy();
    }
}
```
- `new MemoryMemberRepository()` 부분의 중복이 제거되었음
  - 이제 `MemoryMemberRepository()`를 다른 구현체로 변경할 때 한 부분만 변경하면 됨
    - 기존에는 두 부분이었음
  - `AppConfig()`를 보면 역할과 구현 클래스가 한 눈에 들어온다
    - 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악 가능
## 새로운 구조와 할인 정책 적용
## 전체 흐름 정리
## 좋은 객체 지향 설계의 5가지 원칙의 적용
## IoC, DI, 컨테이너
## 스프릥으로 전환
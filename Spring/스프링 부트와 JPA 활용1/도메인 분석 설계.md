## 요구사항 분석
- ![image](https://user-images.githubusercontent.com/102513932/199509559-4b18c0a0-7378-4e2e-bf52-0b90dcdf3568.png)
  - 실제 동작하는 화면을 먼저 확인
### 기능 목록
- 회원 기능
  - 회원 등록
  - 회원 조회
- 상품 기능
  - 상품 등록
  - 상품 수정
  - 상품 조회
- 주문 기능
  - 상품 주문
  - 주문 내역 조회
  - 주문 취소
- 기타 요구사항
  - 상품은 재고 관리 필요
  - 상품의 종류는 도서, 음반, 영화
  - 상품을 카테고리로 구분 가능
  - 상품 주문시 배송 정보 입력 가능
## 도메인 모델과 테이블 설계
- ![image](https://user-images.githubusercontent.com/102513932/199510029-2793b17d-c30a-4f36-b5e6-b8f4fea117d5.png)
  - 회원, 주문, 상품의 관계
    - 한 번 주문할 때 여러 상품 선택 가능, 한 상품도 여러 주문에 담길 수 있음
      - 주문과 상품은 다대다 관계
        - 하지만 다대다 관계는 관계형 DB는 물론, 엔티티에서도 거의 사용하지 않음 
      - 따라서 그림처럼 주문상품이라는 엔티티 추가
        - 다대다 관계 -> 일대다, 다대일 관계
  - 상품 분류
    - 상품은 도서, 음반, 영화로 구분
      - 상품이라는 공통 톡성을 사용, 상속 구조로 표현
### 회원 엔티티 분석
![image](https://user-images.githubusercontent.com/102513932/199518454-b44f2423-d9d9-45dc-ade1-475474312f57.png)
- 회원(Member): 이름과 임베디드 타입인 주소(Address), 주문(orders) 리스트를 가짐
- 주문(Order): 한 번 주문시 여러 상품을 주문할 수 있으므로, 주문과 주문상품(orderItem)은 일대다 관계임
  - 주문은 상품을 주문한 회원과 배송 정보, 주문 날짜, 주문 상태(status)를 지님
  - 주문 상태는 열거형을 사용, 주문(Order), 취소(Cancle)표현 가능
- 주문상품(OrderItem): 주문한 상품 정보와 주문 금액(OrderPrice), 주문 수량(count)정보를 지님
  - 보통 OrderLine, LineItem으로 많이 표현
- 상품(Item): 이름, 가격, 재고수량(stockQuantity)를 가짐
  - 상품을 주문하면 재고수량이 줄어듬
  - 상품의 종류로는 도서, 음반, 영화 존재
    - 각각 사용하는 속성이 조금씩 다름
- 배송(Delivery): 주문 시 하나의 배송 정보 생성
  - 주문과 배송은 일대일 관계
- 카테고리(Category): 상품과 다대다 관계
  - parent, child로 부모, 자식 카테고리 연결
- 주소(Address): 값 타입(임베디드 타입)임
  - 회원과 배송(Delivery)에서 사용

> 참고: JPA에서 새로운 값 타입을 직접 정의해서 사용하는 것을 임베디드 타입이라 지칭한다

> 참고: 회원이 주문을 하기 때문에 회원이 주문리스트를 갖는 것은 얼핏 보면 잘 설계한 것 같지만, 그렇지 않음 <br>
> 실무에서는 회원이 주문을 참조하지 않고, 주문이 회원을 참조하는 것으로 충분하다. <br>
> 회원을 통해서 주문이 일어난다 ->X / 주문을 생성할 때 회원이 필요하다 ->O <br>
> 여기서는 일대다, 다대일의 양방향 연관관계를 설명하기 위해서 추가했다.
### 회원 테이블 분석
![image](https://user-images.githubusercontent.com/102513932/199526985-96341d37-ae4b-4332-a348-8b57f3c84bbf.png)
- MEMBER: 회원 엔티티의 Address 임베디드 타입 정보가 회원 테이블에 그대로 들어감
  - DELIBERY 테이블도 마찬가지
- ITEM: 앨범, 도서, 영화 타입을 통합해 하나의 테이블로 만듬
  - 싱글 테이블 전략 활용
  - DTYPE 컬럼으로 타입 구분
- CATEGORY_ITEM : 매핑 테이블을 통해 CATEGORY, ITEM의 다대다 관계를 일대다, 다대일 관계로 풀어냄 

> 참고: 테이블명이 `ORDER`가 아니라 `ORDERS`인 이유는 데이터베이스가 `order by` 때문에 예약어로 잡고 있는 경우가 많기 때문 <br>
> 따라서 관례상 `ORDERS`를 많이 사용한다.

> 참고: 실제 코드에서는 DB에 소문자 + _(언더스코어) 스타일 사용 <br>
> 데이터베이스 테이블명, 컬럼명에 대한 관례는 회사마다 다르다. 보통은 대문자 + _(언더스코어)나 소문자 +_(언더스코어) 방식 중에 하나를 지정해 일관성 있게 사용한다. <br>
> 여기서 설명할 때는 객체와 차이를 나타내기 위해 데이터베이스 테이블, 컬럼명은 대문자를 사용했지만, 실제 코드에서는 소문자 + _(언더스코어)스타일 사용.

### 연관관계 매핑 분석
- 회원과 주문: 일대다, 다대일의 양방향 관계임
  - 따라서 연관관계의 주인을 정해야 함
  - 외래 키가 있는 주문을 연관관계의 주인으로 정하는 것이 좋음
    - `Order.member`를 `ORDERS.MEMBER_ID` 외래 키와 매핑
- 주문상품과 주문: 다대일 양방향 관계임
  - 외래 키가 주문상품에 있으므로, 주문상품이 연관관계의 주인임
    - `OrderItem.order`를 `ORDER_ITEM.ORDER_ID` 외래 키와 매핑
- 주문상품과 상품: 다대일 단방향 관계임
  - `OrderItem.item`을 `ORDER_ITEM.ITEM_ID` 외래 키와 매핑
- 주문과 배송: 일대일 양방향 관계임
  - `Order.delivery`를 `ORDERS.DELIBERY_ID` 외래 키와 매핑
- 카테고리와 상품: `@ManyToMany`를 사용해서 매핑
  - 실무에서 @ManyToMany 사용 금지!!
    - 여기서는 다대다 관계를 예제로 보여주기 위해 추가
> **참고: 외래 키가 있는 곳을 연관관계의 주인으로 정해라** <br>
> 연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제이지, 비즈니스상 우위에 있다고 주인으로 정하면 안된다. <br>
> 예를 들어, 자동차와 바퀴가 있으면 일대다 관계에서 항상 다쪽에 외래 키가 있으므로 외래 키가 있는 바퀴를 연관관계의 주인으로 정하면 된다. <br>
> 물론 자동차를 연관관계의 주인으로 정하는 것이 불가능 한것은 아니지만, 자동차를 연관관계의 주인으로 정하면 자동차과 관리하지 않는 바퀴 테이블의 외래 키 값이 업데이트 되므로 관리와 유지보수가 어렵고, 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 있다.

## 엔티티 클래스 개발1
## 엔티티 클래스 개발2
## 엔티티 설계시 주의점
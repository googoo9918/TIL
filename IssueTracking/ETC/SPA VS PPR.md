## 목차
- [목차](#목차)
- [SPA 핵심 요건](#spa-핵심-요건)
    - [1. CSR(Client-Side Routing)](#1-csrclient-side-routing)
    - [2. 단일 진입점](#2-단일-진입점)
    - [3. 클라이언트 상태 관리](#3-클라이언트-상태-관리)
    - [4. 컴포넌트 기반 UI 구조](#4-컴포넌트-기반-ui-구조)
    - [5. 뷰 단위 갱신](#5-뷰-단위-갱신)
- [SPA VS JSP + PPR 비교](#spa-vs-jsp--ppr-비교)
    - [1. 구조](#1-구조)
    - [2. 라우팅 제어](#2-라우팅-제어)
    - [3. 상태 관리](#3-상태-관리)
    - [4. 뷰 갱신 방식](#4-뷰-갱신-방식)
    - [5. UI 구조](#5-ui-구조)
- [JSP + PPR 방식의 장점](#jsp--ppr-방식의-장점)
    - [JSP의 한계점](#jsp의-한계점)
## SPA 핵심 요건
### 1. CSR(Client-Side Routing)
- 설명
    - URL 변경 시 -> JS가 감지 -> View를 브라우저에서 랜더링
    - 서버에는 요청 X, 브라우저 `History API(pushState, replaceState)`를 통해 조작
- 효과
    - 화면 전환 시 네트워크 요청 없이 반응 빠름
    - 서버 리소스 낭비 최소화
### 2. 단일 진입점
- 설명
    - 오직 하나의 HTML 파일(index.html)만 클라이언트에 전달
    - 이후 모든 URL 접근은 클라이언트 라우터가 처리
- 효과
    - 전체 구조 JS 기반 구성
    - 클라이언트 상태 + 뷰 로직을 하나의 공간에서 일관되게 제어
### 3. 클라이언트 상태 관리
- 설명
    - 로그인 정보, 선택 필터, 탭 활성 상태, 스크롤 위치 등 다양한 상태를 클라이언트 측에서 저장 및 제어
    - 새로고침 없이 상태 지속, 뷰 상태와 연동된 로직 유지
- 효과
    - UX 연속성 확보
    - 상태 기반 화면 갱신
### 4. 컴포넌트 기반 UI 구조
- 설명
    - UI를 작은 단위(컴포넌트)로 나눔
        - 각 컴포넌트는 독립적으로 상태/로직/스타일을 지님
    - 컴포넌트 조합 -> 전체 UI 구성
- 효과
    - 유지보수 용이
        - 재사용성, 독립성, 상태 기반 렌더링 등
    - 테스트 단위화
    - UI 선언적 방식으로 작성 가능
        - 일일히 지시하지 않고, 현재 상태에 따른 UI만 지정 시 framework가 알아서 처리
### 5. 뷰 단위 갱신
- 설명
    - 전체 페이지를 다시 그리는 것이 아닌, 변경 발생 UI 요소만 부분적 업데이트
    - 가상 DOM(Virtual DOM) 혹은 렌더링 최적화를 통해 UI 갱신
- 효과
    - 전체 HTML 렌더링 불필요 -> 성능 개선
    - 부드러운 UI 구현 가능
    - 뷰 갱신과 상태 관리 분리 가능
## SPA VS JSP + PPR 비교
### 1. 구조
- **SPA(Single Page Application)**
    - 클라리언트가 주도권을 가짐, 서버는 오직 데이터를 제공하는 역할에 집중
    - 어떤 화면이 보여지는지 / 어떤 컴포넌트가 언제 렌더링 되는지 모두 브라우저 내의 **JS가 통제**
    - 서버는 HTML을 생성하지 않음
        - 클라이언트에서 동작하는 라우터와 상태 관리 로직이 앱의 흐름을 담당
- **PPR(Partial Page Rendering)**
    - 서버 중심
        - JSP 템플릿 -> HTML 생성 -> 클라이언트 응답
    - 클라이언트는 HTML을 단순 렌더링
    - 화면 일부를 Ajax로 갱신할 뿐, 전체적 구조 제어권은 서버에 존재
### 2. 라우팅 제어
- **SPA**
    - `History API(pushState, replaceState)` 이용, URL이 변경 감지를 통해 서버에 요청을 보내지 않고 클라이언트 내에서 화면 전한
    - 즉, 클라이언트 라우터가 URL 변경을 감지하고 컴포넌트를 렌더링 함
- **PPR**
    - 페이지 이동 시 마다 서버에 새 요청을 보내고, 이에 대응하는 JSP를 렌더링하여 HTML 응답
    - 라우팅을 JS의 Hash(`#/list`)등을 통해 흉내낼 수는 있음
        - 다만 브라우저 히스토리 통제를 온전히 하기는 어려움
### 3. 상태 관리
- **SPA**
    - 상태 중심 애플리케이션
    - 로그인 정보, 필터 상태, 폼 입력 내용, 스크롤 위치 등 다양한 상태를 클라이언트 메모리 내에서 관리
        - 상태 변화가 곧 컴포넌트의 렌더링으로 연결됨
        - UX 개선
- **PPR**
    - 클라이언트 상태 관리가 구조적으로 어려움
    - 페이지 이동 시 HTML이 완전 재생성
        - 필터나 검색 조건 등의 상태는 서버 세션에 저장 OR URL 파라미터를 통해 전달받아야 유지됨
### 4. 뷰 갱신 방식
- **SPA**
    - Virtual DOM을 통해 상태 변경 시 해당 변경점만 감지하여 화면 갱신
    - 선언형 프로그래밍 방식 기반
        - "무엇을 보여줄 것인가"에만 집중
        - 유지보수성과 확장성이 뛰어남
- **PPR**
    - 뷰 갱신이 명령형 방식
        - 액션에 따라 Ajax로 요청 -> 응답을 통해 삽입
        - 상태와 DOM 사이 일관성 유지 어려움
        - 뷰 갱신에 대한 제어가 낮음
        - 렌더링 최적화 X
### 5. UI 구조
- **SPA**
    - 독립적 컴포넌트 단위로 구성
    - 각 컴포넌트는 상태, 이벤트 핸들러, 스타일을 가짐
        - 재사용 및 테스트 용이
- **PPR**
    - 컴포넌트 기반 설계는 구조적으로 어려움
        - `<jsp:inclue>` 등을 통해 파일 분리는 가능
            - 단순히 정적 템플릿 분할, 상태 기반 렌더링이나 동적 뷰 재구성은 지원하지 않음
            - JS로 UI 요소를 분리해도 HTML, 데이터, 이벤트 로직이 분산됨
                - 관심사 분리의 어려움, 재사용성과 테스트 가능성 떨어짐
            - UI는 페이지 단위의 정적 구성으로 유지
                - 규모가 커질수록 복잡도 증가

## JSP + PPR 방식의 장점
- SSR 기반 안정성과 일관성
    - 서버 중심의 요청/응답 흐름 명확하게 구성
        - 데이터 -> 서비스 -> 컨트롤러 -> 렌더링 구조는 일관된 코드 유지에 유리함
- SEO(Search Engine Optimization), 초기 렌더링 속도 우수
    - JS를 기다리지 않고 바로 렌더링 가능한 콘텐츠 제공
        - 초기 로딩 속도가 빠름
            - 마케팅/검색 유입이 중요한 서비스에서 유리(ex: 공공 포털, 정책 정보 시스템)
- 프레임워크 의존도 낮음
    - React, Vue, Angular 등이 없이도 작동
        - 별도 빌드 도구, 복잡한 상태 관리, 라우팅 시스템 없이도 화면 구현 가능
- PPR 도입을 통한 UX 개선
    - SSR 구조의 연속성과 보안성을 유지하면서도, SPA처럼 부드러운 동작 일부 구현 가능
- 통합 보안 관리 용이
    - 컨트롤러 단에서 인증/인가 처리 가능
    - 세션 기반 인증 로직 구현 용이, 보안 페이지별 접근 제어 명확하게 구성 가능
    - 클라이언트에서 토큰이나 상태를 따로 유지할 필요가 없기 때문에 보안 사고 가능성도 낮음
- 운영 및 배포 환경 단순
    - SPA는 정적 서버, API 서버, 프론트엔드 빌드 파이프라인 등 모두 별도로 구성
    - JSP + SpringBoot는 하나의 WAR/JAR로 통합 배포 가능
        - 정적 리소스, 템플릿, 컨트롤러, 비즈니스 로직 하나의 시스템에 통합 
        - CI/CD 파이프라인 구성 상대적으로 단순함


### JSP의 한계점
- 2009년 이후 공식적 기술적 기능 추가나 구조 변경이 이뤄지지 않음
    - JSP는 더 이상 기능 확장, 성능 최적화, 현대 웹에 대한 대응이 이뤄지지 않음
        - 사실상 정지된 기술
- SpringBoot 3.x이후에는 JSP 연동 자체를 권장하지 않으며, 공식 문서에서도 대체 View 기술을 사용하라고 명시되어 있음
    - `"JSPs are not supported when using an executable jar. If possible, JSPs should be avoided. There are several known limitations when using them with embedded servlet containers.`
    - JAR 패키징 시 JSP는 지원되지 않음
        - 내장 서블릿 컨테이나(Tomcat)과의 호환성 문제
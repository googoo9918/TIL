### 목차
- [컨테이너 기술과 Docker의 탄생 배경](#컨테이너-기술과-docker의-탄생-배경)
  - [컨테이너](#컨테이너)
  - [컨테이너 방식의 장점](#컨테이너-방식의-장점)
    - [컨테이너의 격리](#컨테이너의-격리)
    - [개발 시 문제 해결](#개발-시-문제-해결)
    - [배포 시 문제 해결](#배포-시-문제-해결)
    - [수평 확장과 새로운 내용의 배포](#수평-확장과-새로운-내용의-배포)
    - [이미지](#이미지)
    - [레지스트리](#레지스트리)

# 컨테이너 기술과 Docker의 탄생 배경
## 컨테이너
- 어떤 환경에서나 실행하기 위해 필요한 모든 요소를 포함하는 소프트웨어 패키지
  - 컨테이너 기술은 있지만, 애플리케이션을 쉽게 컨테이너화 할 수 있는 생태계 또는 커뮤니티가 없었음
  - Docker의 등장으로 쉽게 애플리케이션을 포장하고, 컨테이너 방식으로 실행할 수 있게 됨
- 애플리케이션이 의존성, 네트워크 환경, 파일 시트템에 구애받지 않고 도커라는 기술 위에 실행될 수 있도록 만든 애플리케이션 상자
## 컨테이너 방식의 장점
- 의존성 충돌 문제를 해결
  - 개발과 배포 환경을 일치시킴
  - 수평 확장을 용이하게함
  - 각 서버에 새로운 내용 배포를 용이하게 함
- 특정 애플리케이션은 실행을 위해 특정 환경의 구축이 필요할 때가 있음
  - 어떤 프로그램(A)의 실행에 다른 프로그램(B)가 필요한 경우, 프로그램 A는 프로그램 B에 **의존 관계를 갖고 있음**
- 프로그램 뿐 아니라, 프로그램의 특정 버전을 요구하는 경우도 있음
  - 프로그램 A는 php 7버전을 요구
  - 프로그램 B는 php 6버전을 요구
  - 일반적으로 여러 버전의 php를 갖고 있지 않으므로, php에 의존 관계를 갖는 두 프로그램 중 하나는 제대로 된 실행을 보장할 수 없음
    - **의존성 충돌 발생**
- 컨테이너 기술은 위와 같은 문제를 해결함
  - 컨테이너에서 실행 중인 애플리케이션은 어떠한 의존성도 공유하지 않음
    - 각자 고유의 의존성 포함
  - 실행 환경이 격리되어 있음
  - ![image](https://user-images.githubusercontent.com/102513932/205788951-fbedd8bb-8db2-4a3c-bf97-43c272d838f5.png)

### 컨테이너의 격리
- 1. 프로세스
  - 특정 컨테이너에서 작동하는 프로세스는 기본적으로 컨테이너 안에서만 액세스할 수 있음
  - 컨테이너 안에서 실행되는 프로세스는 다른 컨테이너의 프로세스에게 영향을 줄 수 없음
- 2. 네트워크
  - 기본적으로 컨테이너 하나에 하나의 IP 주소가 할당되어 있음
- 3. 파일 시스템
  - 컨테이너 안에서 사용되는 파일 시스템은 구획화 되어 있어서 해당 컨테이너에서의 명령이나 파일 등의 액세스를 제한할 수 있음

### 개발 시 문제 해결
- 여러 개발자가 하나의 애플리케이션을 만들기 위해 보통 비슷한 개발 환경을 구축함
  - 특정 버전 이상의 JDK, 특정 버전의 MySQL 등을 각자의 운영체제의 설치
  - OS나 JDK, Node.js 등 런타임 환경의 버전 또한 얼추 비슷하게 맞춰야 함
  - 시스템 환경 변수를 애플리케이션에 맞게 구성해야함
- 개발 환경을 구축하는데 있어서, 각종 문제가 발생함
  - 배포판에 따라 전혀 다른 애플리케이션 설치 과정이 진행됨
    - 이러한 과정 중에 발생하는 문제는 해결에 많은 시간이 소모됨
    - 특히 새로운 프로젝트에 투입되는 개발자의 경우, 애플리케이션을 실행하기 까지 가는 과정이 매우 험난함
- 도커가 이러한 문제를 해결함
  - 어떤 운영체제든 상관없이 다음 명령어로 즉시 PostgreSQL을 설치하고 실행할 수 있음
  - `docker run --name postgres -e POSTGRES_PASSWORD = mysecret -d postgres`
    - 단일 소프트웨어 사례
  - 애플리케이션 구성 자체가 컨테이너화 됐을 시
    - Docker Compose 툴 사용
      - YAML 파일 + 명령어 하나로 모든 실행 환경 구성이 완료됨
      - `docket-compose up`
- 즉, 도커는 OS에 상관없이 즉시 애플리케이션 실행 환경을 구축할 수 있음
- 개발을 컨테이너 위에서 진행할 경우, 모든 개발팀이 동일한 환경 하에 개발을 진행할 수 있음

### 배포 시 문제 해결
- 개발에서 발생한 실행 및 환경의 일치 이슈는 서비스 배포 환경에서도 동일하게 적용됨
- 따라서 AWS의 EC2 상에 도커를 설치하거나 편리하게 도커 컨테이너를 EC2 서버에서 실행할 수 있게 하는 서비스인 **ECS**를 이용하여 보다 쉽게 애플리케이션 배포 가능

### 수평 확장과 새로운 내용의 배포
- 글로벌 웹 서비스는 트래픽이 매우 높음
  - ex) google
- ![image](https://user-images.githubusercontent.com/102513932/205790731-c175282b-1fcc-4d93-8625-8b4560e49a71.png)
  - 서비스 제공자들은 트래픽 분산을 위해 프록시 서버를 운영함
    - 프록시 서버는 여러 대의 동일한 검색 서버 중 한 군데를 이용할 수 있도록 도움
  - 컨테이너 기술의 가장 큰 장점은 **실행 환경의 일치**
  - 더 많은 트래픽으로 인한 서버 증설에 컨테이너 기술이 용이하게 사용됨
  - 동일한 애플리케이션 구성을 바탕으로 새로운 서버에 해당 애플리케이션을 컨테이너로 실행 후, 로드 밸런서에 서버를 추가하기만 하면 됨
- - ![image](https://user-images.githubusercontent.com/102513932/205791626-76737068-6a9e-4620-a9c1-f6c06b6e36f5.png)
  - 새로운 버전의 애플리케이션을 여러 서버 중 몇 곳에만 운영하여 테스트 할 수도 있음
  - 새 버전의 애플리케이션에서 발생할 수 있는 문제들을 미리 확인
    - 이러한 문제가 사용자 전체에게 영향을 끼치지 않도록 함

### 이미지
- 애플리케이션 및 애플리케이션 구성을 함께 담아놓은 템플릿
  - 이를 이용해 즉시 컨테이너를 만들 수 있음 
  - 실행되는 모든 컨테이너는 이미지로부터 생성됨
  - 이미지를 이용해 여러 개의 컨테이너 생성 가능
    - 수평 확장 가능
  - 기본 이미지로부터 변경 사항을 추가/커밋하여 또 다른 이미지를 만들 수도 있음
### 레지스트리
- 이미지는 레지스트리에 저장됨
  - 대표적인 이미지 레지스트리 : Docker Hub, Amazon ECR
- 도커 CLI에서 이미지를 이용해 컨테이너 생성 시
  - 호스트 컴퓨터에 이미지가 존재하지 않으면 기본 레지스트리로부터 다운받게 됨
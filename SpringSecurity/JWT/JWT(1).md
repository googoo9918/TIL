### 목차
- [토큰 기반 자격 증명](#토큰-기반-자격-증명)
  - [세션 기반 자격 증명 방식](#세션-기반-자격-증명-방식)
    - [특징](#특징)
  - [토큰 기반 자격 증명 방식](#토큰-기반-자격-증명-방식)
    - [특징](#특징-1)
  - [JWT(JSON Web Token)](#jwtjson-web-token)
    - [JWT의 종류](#jwt의-종류)
    - [JWT 구조](#jwt-구조)
      - [1. Header](#1-header)
      - [2. Payload](#2-payload)
      - [3. Signautre](#3-signautre)
    - [JWT 사용 예시](#jwt-사용-예시)
    - [토큰기반 인증 절차](#토큰기반-인증-절차)
  - [JWT 인증 장점](#jwt-인증-장점)
  - [JWT 인증 단점](#jwt-인증-단점)
# 토큰 기반 자격 증명
- HTTP 프로토콜은 비연결성과 비상태성의 특성을 지님
  - 비연결성 : response를 수신하면 연결을 끊음
  - 비상태성 : 로그인 인증이 성공적으로 수행되어도 서버 측에서는 수신하는 request가 인증된 사용자가 보낸 request인지 확인할 수 없음
- 이러한 특성으로 인해 사용자의 인증이 성공적으로 이뤄졋을 때, 인증된 사용자 상태를 유지하기 위한 수단이 필요해짐
  - 대표적인 수단이 *세션*임

## 세션 기반 자격 증명 방식
- 서버 측에 인증된 사용자의 정보를 세션 형태로 세션 저장소에 저장
  - 클라이언트 측에서 서버 측의 리소스 요청 시
    - 서버 측에서는 서버 측 세션 저장소에 저장된 세션 정보와, 사용자가 제공하는 정보가 일치하는지 확인
    - 클라이언트에게 정보를 줘도 괜찮은지 판단
### 특징
- 세션은 인증된 사용자 정보를 서버 측 세션 저장소에서 관리함
- 생성된 사용자 세션의 고유 ID인 세션ID는 클라이언트 쿠키에 저장됨
  - request 전송 시, 인증된 사용자인지를 증명
- 세션 ID만 클라이언트 쪽에서 사용하므로, 상대적으로 적은 네트워크 트래픽 사용
- 서버 측에서 세션 정보를 관리하므로 보안성 측면에서 보다 유리함
- 서버의 확장성 측면에서, 세션 불일치 문제가 발생할 가능성이 높음
- 세션 데이터가 많아질수록 **서버의 부담이 가중**됨
- SSR(Server Side Rendering)방식의 애플리케이션에 적합한 방식임

## 토큰 기반 자격 증명 방식 
- 토큰을 통해 인증된 사용자의 자격을 증명하는 동시에 접근 권한을 부여
  - 접근 권한이 부여된 특정 리소스에만 접근 가능하게 함
### 특징
- 토큰에 포함된 인증된 사용자 정보는 서버 측에서 별도의 관리를 하지 않음
- 토큰을 헤더에 포함시켜 request 전송 시, 인증된 사용자인지를 증명하는 수단으로 사용됨
- 토큰내에 인증된 사용자 정보 등을 포함하고 있으므로 세션에 비해 상대적으로 많은 **네트워크 트래픽** 사용
- 서버 측에서 토큰을 관리하지 않으므로 보안성 측면에서 보다 불리함
- 인증된 사용자 request 상태를 유지할 필요 없음
  - 서버의 확장성 면에서 유리, 세션 불일치 같은 문제가 발생하지 않음
- 토큰에 포함되는 사용자 정보는 토큰 특성상 암호화 되지 않음
  - 공격자에게 토큰이 탈취되는 경우, 사용자 정보를 그대로 제공함
  - 민감한 정보는 토큰에 포함시키지 않아야 함
- 토큰이 만료되기 전까지는 토큰을 무효화 시킬 수 없음
- CSR(Client Side Rendering) 방식의 애플리케이션에 적합한 방식

> 세션의 경우 서버 확장 시, 서버 불일치 문제가 발생할 수 있지만 Sticky Session, Session clustering, Session 저장소의 외부 분리 등의 작업을 통해 보완하고 있음 <br>
> 토근의 경우, 기본적으로 토큰 무효화를 할 수 없지만 Redis 같은 인메모리 DB에 무효화 시키고자 하는 토큰의 만료 시간을 설정하여 토큰을 사용하지 못하게 하는 등의 방법을 사용, 토큰 무효화 문제를 보완함

## JWT(JSON Web Token)
- JWT는 데이터를 안전하고 간결하게 전송하기 위해 고안된 인터넷 표준 인증 방식
  - 토큰 인증 방식에서 가장 범용적으로 사용됨
- JSON 포맷의 토큰 정보를 인코딩
  - 인코딩 된 토큰 정보를 Secret Key로 서명한 메시지를 Web Token으로써 인증 과정에 사용
- [JWT 공식 사이트](https://jwt.id/)

### JWT의 종류
- JWT는 다음과 같이 두 가지 종류의 토큰을 사용자의 자격 증명에 이용
  - 1. 엑세스 토큰 (Access Token)
  - 2. 리프레시 토큰 (Refresh Token)
- 엑세스 토큰은 보호된 정보들에 접근할 수 있는 권한부여에 사용
- 클라이언트가 처음 인증을 받을 때(로그인), Access Token과 Refresh Token 두 가지를 다 받음
  - 실제로 권한을 얻는데 사용하는 토큰은 Access Token 밖에 없음
  - 따라서 Access Token이 탈취되면 위험도가 큼
    - Access Token은 비교적 **짧은 유효 기간**을 설정, 탈취되더라도 오랫동안 사용할 수 없도록 함
  - Access Token의 유효기간 만료 시, Refresh Token을 사용하여 새로운 Access Token을 발급받음
    - 물론, 사용자는 다시 로그인 인증을 할 필요 없음
  - 두 토큰 모두 탈취 당한다면?
    - 방법이 없음, 따라서 사용자의 편의보다 정보를 지키는 것이 더 중요한 웹 애플리케이션은 Refresh Token을 사용하지 않음
### JWT 구조
- ![image](https://user-images.githubusercontent.com/102513932/203459309-5d48684d-a52d-447a-9021-041c15e74133.png)

#### 1. Header
- Header는 어떤 종류의 토큰인지, 어떤 알고리즘으로 Sign할지 정의함
- JSON Web Token에 걸맞게 JSON 포맷 형태로 정의하게됨
```JSON
{
    "alg": "HS256",
    "typ": "JWT"
}
```
- 이 JSON 객체를 base64 방식으로 인코딩 시 JWT의 첫 번째 부분이 완성됨

#### 2. Payload
- 서버에서 활용할 수 있는 사용자의 정보가 담겨있음
  - 어떤 정보에 접근 가능한지에 대한 권한을 담을 수 있음
  - 사용자의 이름 등 필요한 데이터를 담을 수 있음
  - Signature를 통해 유효성이 검증될 정보이지만, 민감한 정보는 담지 않는 것이 좋음
```JSON
{
    "sub": "someInformation",
    "name": "phillip",
    "iat": 151623391
}
```
- 첫 번째 부분과 마찬가지로, 위 JSON 객체를 base64로 인코딩하면 JWT의 두 번째 블록이 완성됨

#### 3. Signautre
- base64로 인코딩된 첫 번째, 두 번째 부분 완성 시
  - Signature에서는 원하는 비밀 키(Secret Key)와 Header에서 지정한 알고리즘을 사용
    - Header와 Payload에 대해 단방향 암호화를 수행함
  - 암호화된 메시지는 토큰의 위변조 유무를 검증하는데 사용
- ex) HMAC SHA256 알고리즘 사용 시
```
HMACSHA256(base64UrlEncode(header)+ '.' + base64UrlEncdoe(payload), secret);
```

### JWT 사용 예시
- JWT는 `권한 부여`에 매우 유용함
- 새로 다운받은 `A`라는 앱이 Gmail과 연동되어 이메일을 읽어와야 한다 가정
- 사용자 행동
  - 1. Gmail 인증서버에 로그인 정보 제공
  - 2. 인증 성공 시, JWT 발급
  - 3. A 앱은 JWT를 사용해 해당 사용자의 이메일을 읽거나 사용할 수 있음

### 토큰기반 인증 절차
![image](https://user-images.githubusercontent.com/102513932/203460997-4b9cdb47-da43-492b-81b7-078497e14a54.png)
- 1. 클라이언트가 서버에 아이디/비밀번호를 담아 로그인 요청을 보냄
- 2. 아이디/비밀번호가 일치하는 지 확인, 클라이언트에게 보낼 암호화 된 토큰 생성
   - Access Token과 Refresh Token 모두 생성
      - 토큰에 담길 정보는 사용자를 식별할 정보, 사용자의 권한 정보 등이 될 수 있음
      - Refresh Token을 이용해 새로운 Access Token 생성
        - 두 종류의 토큰이 같은 정보를 담을 필요는 없음
- 3. 토큰을 클라이언트에게 전송, 클라이언트는 토큰을 저장
  - 저장 위치는 Local Storage, Session Storage, CooKie 등 가능
- 4. 클라이언트가 HTTP header(Authorization Header) 또는 쿠키에 토큰을 담아 request를 전송
- 5. 서버는 토큰을 검증후 응답 전송


## JWT 인증 장점
- 상태를 유지하지 않고(Stateless), 확장에 용이한(Scalable) 애플리케이션을 구현하기 용이함
  - 서버는 클라이언트에 대한 정보를 저장할 필요가 없음
    - 토큰이 정상적으로 검증되는지만 판단함
  - 클라이언트는 request를 전송할 때 마다 토큰을 헤더에 포함시키면 됨
    - 여러대의 서버를 이용한 서비스라면, 하나의 토큰으로 여러 서버에서 인증 또한 가능
      - JWT를 사용하는 것이 효과적임
      - 만약 세션 방식이라면 모든 서버가 사용자의 세션 정보를 공유하고 있어야 함
- 클라이언트가 request를 전송할 때 마다 자격 증명 정보를 전송할 필요가 없음
  - 토큰이 만료되기 전까지, 한 번의 인증만 수행하면 됨
- 인증을 담당하는 시스템을 다른 플랫폼으로 분리하는 것이 용이함
  - 사용자의 자격 증명 정보를 직접 관리하지 않고, Github, Google 등의 다른 플랫폼의 자격 증명 정보로 인증하는 것이 가능
  - 토큰 생성용 서버를 만들거나, 타 회사에 토큰 관련 작업을 맡기는 것 등 다양한 활용 가능
- 권한 부여 용이
  - 토큰의 Payload 안에 해당 사용자의 권한 정보를 포함하는 것이 용이함

## JWT 인증 단점
- Payload는 디코딩이 용이함
  - Payload는 base64로 인코딩 되기 때문에 토큰을 탈취하여 Payload를 디코딩하면 토큰 생성 시 저장한 데이터 확인 가능
    - 따라서 Paylaod에는 민감한 정보를 포함하지 않아야 함
- 토큰의 길이가 길어지면 네트워크에 부하를 줄 수 있음
  - 토큰에 저장하는 정보의 양이 많아지면, 토큰의 길이는 길어짐
    - 따라서 request를 전송할 때 마다 길이가 긴 토큰을 함께 전송사면 네트워크에 부하를 줄 수 있음
      - 따라서 Payload에는 너무 많은 정보를 포함하지 않아야 함
- 토큰은 자동으로 삭제되지 않음
  - 한 번 생성된 토큰은 자동으로 삭제되지 않기 때문에, 토큰 만료 시간을 반드시 추가해야함
  - 토큰이 탈취될 경우 기한이 만료될 때까지 토큰 탈취자가 해당 토큰을 정상적으로 이용할 수 있음
    - 만료 시간을 너무 길게 설정하지 않아야 함
